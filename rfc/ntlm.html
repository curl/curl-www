<html>
<head>
<title>The NTLM Authentication Protocol</title>
</head>
<body>
<h1>The NTLM Authentication Protocol</h1>
<p>
<small>
    Copyright &copy; 2003 Eric Glass
    <p>
    Permission to use, copy, modify, and distribute this document for
    any purpose and without any fee is hereby granted, provided that the
    above copyright notice and this list of conditions appear in all copies.
    <p>
    The most current version of this document may be obtained from
    <a href="http://davenport.sourceforge.net/ntlm.html">http://davenport.sourceforge.net/ntlm.html</a>.
</small>
</p>
<h2>Abstract</h2>
<p>
This article seeks to describe NTLM at an intermediate to advanced level of
detail, suitable as a reference for implementors.  It is hoped that this
document will evolve into a comprehensive description of NTLM; at this
time there are omissions, both in the author's knowledge and in his
documentation, and almost certainly inaccuracies.  However, this document
should at least be able to provide a solid foundation for further research.  The
information presented herein was used as the basis for the implementation of
NTLM in the open-source jCIFS library, available at
<a href="http://jcifs.samba.org">http://jcifs.samba.org</a>.
<p>

<h2>Contents</h2>
<ul>
<li><a href="#whatIsNtlm">What is NTLM?</a></li>
<li><a href="#ntlmDataTypes">NTLM Data Types</a></li>
<li>
<a href="#theNtlmMessageHeaderLayout">The NTLM Message Header Layout</a>
    <ul>
    <li><a href="#theNtlmFlags">The NTLM Flags</a></li>
    </ul>
</li>
<li>
<a href="#theType1Message">The Type 1 Message</a>
    <ul>
    <li><a href="#type1MessageExample">Type 1 Message Example</a></li>
    </ul>
</li>
<li>
<a href="#theType2Message">The Type 2 Message</a>
    <ul>
    <li><a href="#type2MessageExample">Type 2 Message Example</a></li>
    </ul>
</li>
<li>
<a href="#theType3Message">The Type 3 Message</a>
    <ul>
    <li>
    <a href="#respondingToTheChallenge">Responding to the Challenge</a>
        <ul>
        <li><a href="#theLmResponse">The LM Response</a></li>
        <li><a href="#theNtlmResponse">The NTLM Response</a></li>
        <li><a href="#theNtlmv2Response">The NTLMv2 Response</a></li>
        <li><a href="#theLmv2Response">The LMv2 Response</a></li>
        <li><a href="#theNtlm2SessionResponse">The NTLM2 Session Response</a></li>
        </ul>
    </li>
    <li><a href="#type3MessageExample">Type 3 Message Example</a></li>
    </ul>
</li>
<li><a href="#ntlmVersion2">NTLM Version 2</a></li>
<li>
<a href="#ntlmsspAndSspi">NTLMSSP and SSPI</a>
    <ul>
        <li><a href="#localAuthentication">Local Authentication</a></li>
        <li><a href="#datagramAuthentication">Datagram Authentication</a></li>
    </ul>
</li>
<li><a href="#ntlmHttpAuthentication">NTLM HTTP Authentication</a></li>
<li><a href="#ntlmPop3Authentication">NTLM POP3 Authentication</a></li>
<li><a href="#ntlmImapAuthentication">NTLM IMAP Authentication</a></li>
<li><a href="#ntlmSmtpAuthentication">NTLM SMTP Authentication</a></li>
<li><a href="#linksAndReferences">Links and References</a></li>
<li><a href="#appendixA">Appendix A:  Java Implementation of the Type 3 Response Calculations</a></li>
</ul>
<hr>

<a name="whatIsNtlm">
<h2>What is NTLM?</h2>
<p>
NTLM is an authentication protocol used in various Microsoft network protocol
implementations and supported by the NTLM Security Support Provider ("NTLMSSP").
Originally used for authentication and negotiation of secure DCE/RPC, NTLM is
also used throughout Microsoft's systems as an integrated single sign-on
mechanism.
<p>
NTLM employs a challenge-response mechanism for authentication, in which
clients are able to prove their identities without sending a password to the
server.  It consists of three messages, commonly referred to as Type 1
(negotiation), Type 2 (challenge) and Type 3 (authentication).
It basically works like this:
<p>
<ol>
<li>
The client sends a Type 1 message to the server.  This primarily contains a
list of features supported by the client and requested of the server.
</li>
<li>
The server responds with a Type 2 message.  This contains a list of features
supported and agreed upon by the server.  Most importantly, however, it
contains a challenge generated by the server.
</li>
<li>
The client replies to the challenge with a Type 3 message.  This contains
several pieces of information about the client, including the domain and
username of the client user.  It also contains one or more responses to the
Type 2 challenge.
</li>
</ol>
<p>
The responses in the Type 3 message are the most critical piece, as they prove
to the server that the client user has knowledge of the account password.

<a name="ntlmDataTypes">
<h2>NTLM Data Types</h2>
<p>
Before we start digging in any further, we will need to define a few data
types as used in the messages.
<p>
For our purposes, a "<tt>short</tt>" is a little-endian, 16-bit unsigned value.
For example, the decimal value "<tt>1234</tt>" represented as a <tt>short</tt>
would be physically laid out as "<tt>0xd204</tt>" in hexadecimal.
<p>
A "<tt>long</tt>" is a little-endian, 32-bit unsigned value.  The decimal value
"<tt>1234</tt>" represented as a <tt>long</tt> in hexidecimal would be
"<tt>0xd2040000</tt>".
<p>
A Unicode string is a string in which each character is represented as a
16-bit little-endian value (16-bit UCS-2 Transformation Format,
little-endian byte order, with no Byte Order Mark and no null-terminator).
The string "hello" in Unicode would be represented hexidecimally as
"<tt>0x680065006c006c006f00</tt>".
<p>
An OEM string is a string in which each character is represented as an
8-bit value from the local machine's native character set (DOS codepage).
There is no null-terminator.  In NTLM messages, OEM strings are typically
presented in uppercase.  The string "HELLO" in OEM would be represented
hexidecimally as "<tt>0x48454c4c4f</tt>".
<p>
A "security buffer" is a structure used to point to a buffer of binary data.
It consists of:
<ol>
<li>
A <tt>short</tt> containing the length of the buffer in bytes.
</li>
<li>
A <tt>short</tt> containing the allocated space for the buffer in bytes
(typically, though not necessarily, the same as the length).
</li>
<li>
A <tt>long</tt> containing the offset to the start of the buffer in bytes
(from the beginning of the NTLM message).
</li>
</ol>
<p>
So the security buffer "<tt>0xd204d204e1100000</tt>" would be read as:
<p>
Length: <tt>0xd204</tt> (1234 bytes)
<br>
Allocated Space: <tt>0xd204</tt> (1234 bytes)
<br>
Offset: <tt>0xe1100000</tt> (4321 bytes)
<p>
If you started at the first byte in the message, and skipped ahead 4321 bytes,
you would be at the start of the data buffer.  You would read 1234 bytes
(which is the length of the buffer).  Since the allocated space for the buffer
is also 1234 bytes, you would then be at the end of the buffer.

<a name="theNtlmMessageHeaderLayout">
<h2>The NTLM Message Header Layout</h2>
<p>
Now we're ready to look at the physical layout of NTLM message headers.
<p>
All messages start with the NTLMSSP signature, which is (aptly enough) the
null-terminated ASCII string "NTLMSSP" (hexadecimal
"<tt>0x4e544c4d53535000</tt>").
<p>
Next is a <tt>long</tt> containing the message type (1, 2, or 3).  A Type 1
message, for example, has type "<tt>0x01000000</tt>" in hex.
<p>
This is followed by message-specific information, typically consisting of
security buffers and the message flags.

<a name="theNtlmFlags">
<h3>The NTLM Flags</h3>
<p>
The message flags are contained in a bitfield within the header.  This is a
<tt>long</tt>, in which each bit represents a specific flag.  Most of these
will make more sense later, but we'll go ahead and present them here to
establish a frame of reference for the rest of the discussion.
Many of these flags are not used, or are used infrequently; commonly
occurring flags are displayed in bold in the table below.  Flags marked as
"unidentified" or "unknown" are outside the realm of the author's knowledge
(which is not by any means absolute).
<p>
<table cellpadding="3" border="1">
<tr valign="top">
    <th>Flag</th><th>Name</th><th>Description</th>
</tr>
<tr valign="top">
    <td><tt><b>0x00000001</b></tt></td><td><b>Negotiate Unicode</b></td>
    <td>
        Indicates that Unicode strings are supported for use in security
        buffer data.
    </td>
</tr>
<tr valign="top">
    <td><tt><b>0x00000002</b></tt></td><td><b>Negotiate OEM</b></td>
    <td>
        Indicates that OEM strings are supported for use in security buffer
        data.
    </td>
</tr>
<tr valign="top">
    <td><tt><b>0x00000004</b></tt></td><td><b>Request Target</b></td>
    <td>
        Requests that the server's authentication realm be included in the
        Type 2 message.
    </td>
</tr>
<tr valign="top">
    <td><tt>0x00000008</tt></td><td><i>unknown</i></td>
    <td>
        <i>This flag's usage has not been identified.</i>
    </td>
</tr>
<tr valign="top">
    <td><tt>0x00000010</tt></td><td>Negotiate Sign</td>
    <td>
        Specifies that authenticated communication between the client and
        server should carry a digital signature (message integrity).
    </td>
</tr>
<tr valign="top">
    <td><tt>0x00000020</tt></td><td>Negotiate Seal</td>
    <td>
        Specifies that authenticated communication between the client and
        server should be encrypted (message confidentiality).
    </td>
</tr>
<tr valign="top">
    <td><tt>0x00000040</tt></td><td>Negotiate Datagram Style</td>
    <td>
        Indicates that datagram authentication is being used.
    </td>
</tr>
<tr valign="top">
    <td><tt>0x00000080</tt></td><td>Negotiate Lan Manager Key</td>
    <td>
        Indicates that the LAN Manager session key should be used for
        signing and sealing authenticated communications.
    </td>
</tr>
<tr valign="top">
    <td><tt>0x00000100</tt></td><td>Negotiate Netware</td>
    <td>
        <i>This flag's usage has not been identified.</i>
    </td>
</tr>
<tr valign="top">
    <td><tt><b>0x00000200</b></tt></td><td><b>Negotiate NTLM</b></td>
    <td>
        Indicates that NTLM authentication is being used.
    </td>
</tr>
<tr valign="top">
    <td><tt>0x00000400</tt></td><td><i>unknown</i></td>
    <td>
        <i>This flag's usage has not been identified.</i>
    </td>
</tr>
<tr valign="top">
    <td><tt>0x00000800</tt></td><td><i>unknown</i></td>
    <td>
        <i>This flag's usage has not been identified.</i>
    </td>
</tr>
<tr valign="top">
    <td><tt><b>0x00001000</b></tt></td><td><b>Negotiate Domain Supplied</b></td>
    <td>
        Sent by the client in the Type 1 message to indicate that the name of
        the domain in which the client workstation has membership is included
        in the message.  This is used by the server to determine whether the
        client is eligible for local authentication.
    </td>
</tr>
<tr valign="top">
    <td><tt><b>0x00002000</b></tt></td><td><b>Negotiate Workstation Supplied</b></td>
    <td>
        Sent by the client in the Type 1 message to indicate that the client
        workstation's name is included in the message.  This is used by
        the server to determine whether the client is eligible for local
        authentication.
    </td>
</tr>
<tr valign="top">
    <td><tt><b>0x00004000</b></tt></td><td><b>Negotiate Local Call</b></td>
    <td>
        Sent by the server to indicate that the server and client are on the
        same machine.  Implies that the client may use the established local
        credentials for authentication instead of calculating a response to
        the challenge.
    </td>
</tr>
<tr valign="top">
    <td><tt><b>0x00008000</b></tt></td><td><b>Negotiate Always Sign</b></td>
    <td>
        Indicates that authenticated communication between the client
        and server should be signed with a "dummy" signature.
    </td>
</tr>
<tr valign="top">
    <td><tt><b>0x00010000</b></tt></td><td><b>Target Type Domain</b></td>
    <td>
        Sent by the server in the Type 2 message to indicate that the target
        authentication realm is a domain.
    </td>
</tr>
<tr valign="top">
    <td><tt>0x00020000</tt></td><td>Target Type Server</td>
    <td>
        Sent by the server in the Type 2 message to indicate that the target
        authentication realm is a server.
    </td>
</tr>
<tr valign="top">
    <td><tt>0x00040000</tt></td><td>Target Type Share</td>
    <td>
        <i>Sent by the server in the Type 2 message to indicate that the 
        target authentication realm is a share.  Presumably, this is for
        share-level authentication.  Usage is unclear.</i>
    </td>
</tr>
<tr valign="top">
    <td><tt><b>0x00080000</b></tt></td><td><b>Negotiate NTLM2 Key</b></td>
    <td>
        Indicates that the NTLM2 signing and sealing scheme should be used
        for protecting authenticated communications.  Note that this refers to
        a particular session security scheme, and is not related to the use
        of NTLMv2 authentication.  This flag can, however, have an effect on
        the response calculations (as detailed in the "<a href="#theNtlm2SessionResponse">NTLM2 Session Response</a>" section).
    </td>
</tr>
<tr valign="top">
    <td><tt>0x00100000</tt></td><td>Request Init Response</td>
    <td>
        <i>This flag's usage has not been identified.</i>
    </td>
</tr>
<tr valign="top">
    <td><tt>0x00200000</tt></td><td>Request Accept Response</td>
    <td>
        <i>This flag's usage has not been identified.</i>
    </td>
</tr>
<tr valign="top">
    <td><tt>0x00400000</tt></td><td>Request Non-NT Session Key</td>
    <td>
        <i>This flag's usage has not been identified.</i>
    </td>
</tr>
<tr valign="top">
    <td><tt><b>0x00800000</b></tt></td><td><b>Negotiate Target Info</b></td>
    <td>
        Sent by the server in the Type 2 message to indicate that it is
        including a Target Information block in the message.  The Target
        Information block is used in the calculation of the NTLMv2 response.
    </td>
</tr>
<tr valign="top">
    <td><tt>0x01000000</tt></td><td><i>unknown</i></td>
    <td>
        <i>This flag's usage has not been identified.</i>
    </td>
</tr>
<tr valign="top">
    <td><tt>0x02000000</tt></td><td><i>unknown</i></td>
    <td>
        <i>This flag's usage has not been identified.</i>
    </td>
</tr>
<tr valign="top">
    <td><tt>0x04000000</tt></td><td><i>unknown</i></td>
    <td>
        <i>This flag's usage has not been identified.</i>
    </td>
</tr>
<tr valign="top">
    <td><tt>0x08000000</tt></td><td><i>unknown</i></td>
    <td>
        <i>This flag's usage has not been identified.</i>
    </td>
</tr>
<tr valign="top">
    <td><tt>0x10000000</tt></td><td><i>unknown</i></td>
    <td>
        <i>This flag's usage has not been identified.</i>
    </td>
</tr>
<tr valign="top">
    <td><tt><b>0x20000000</b></tt></td><td><b>Negotiate 128</b></td>
    <td>
        Indicates that 128-bit encryption is supported.
    </td>
</tr>
<tr valign="top">
    <td><tt>0x40000000</tt></td><td>Negotiate Key Exchange</td>
    <td>
        Indicates that the client will provide an encrypted master session
        key in the "Session Key" field of the Type 3 message.  This is used
        in signing and sealing, and is RC4-encrypted using the previous session
        key as the encryption key.
    </td>
</tr>
<tr valign="top">
    <td><tt><b>0x80000000</b></tt></td><td><b>Negotiate 56</b></td>
    <td>
        Indicates that 56-bit encryption is supported.
    </td>
</tr>
</table>
<p>
As an example, consider a message specifying:
<p>
Negotiate Unicode (<tt>0x00000001</tt>)
<br>
Request Target (<tt>0x00000004</tt>)
<br>
Negotiate NTLM (<tt>0x00000200</tt>)
<br>
Negotiate Always Sign (<tt>0x00008000</tt>)
<p>
Combining the above gives "<tt>0x00008205</tt>".  This would be physically laid
out as "<tt>0x05820000</tt>" (since it is represented in little-endian byte
order).

<a name="theType1Message">
<h2>The Type 1 Message</h2>
<p>
Let's jump in and take a look at the Type 1 message:
<p>
<table cellpadding="5">
<tr valign="top">
    <th align="right"></th><th align="left">Description</th>
    <th align="left">Content</th>
</tr>
<tr valign="top">
    <td align="right">0</td><td>NTLMSSP Signature</td>
    <td>Null-terminated ASCII "NTLMSSP" (<tt>0x4e544c4d53535000</tt>)</td>
</tr>
<tr valign="top">
    <td align="right">8</td><td>NTLM Message Type</td>
    <td><tt>long</tt> (<tt>0x01000000</tt>)</td>
</tr>
<tr valign="top">
    <td align="right">12</td><td>Flags</td><td><tt>long</tt></td>
</tr>
<tr valign="top">
    <td align="right"><i>(16)</i></td><td>Supplied Domain <i>(Optional)</i></td><td>security buffer</td>
</tr>
<tr valign="top">
    <td align="right"><i>(24)</i></td><td>Supplied Workstation <i>(Optional)</i></td>
    <td>security buffer</td>
</tr>
<tr valign="top">
    <td align="right"><i>(32)</i></td><td colspan="2"><i>start of data block (if required)</i></td>
</tr>
</table>
<p>
The Type 1 message is sent from the client to the server to initiate NTLM
authentication.  Its primary purpose is to establish the "ground rules" for
authentication by indicating supported options via the flags.  Optionally,
it can also provide the server with the client's workstation name and 
the domain in which the client workstation has membership; this information
is used by the server to determine whether the client is eligible for
local authentication.
<p>
Typically, the Type 1 message contains flags from the following set:
<p>
<table cellpadding="5">
<tr valign="top">
    <td>Negotiate Unicode (<tt>0x00000001</tt>)</td>
    <td>
        The client sets this flag to indicate that it supports Unicode strings.
    </td>
</tr>
<tr valign="top">
    <td>Negotiate OEM (<tt>0x00000002</tt>)</td>
    <td>
        This is set to indicate that the client supports OEM strings.
    </td>
</tr>
<tr valign="top">
    <td>Request Target (<tt>0x00000004</tt>)</td>
    <td>
        This requests that the server send the authentication target with
        the Type 2 reply.
    </td>
</tr>
<tr valign="top">
    <td>Negotiate NTLM (<tt>0x00000200</tt>)</td>
    <td>
        Indicates that NTLM authentication is supported.
    </td>
</tr>
<tr valign="top">
    <td>Negotiate Domain Supplied (<tt>0x00001000</tt>)</td>
    <td>
        When set, the client will send with the message the name of the domain
        in which the workstation has membership.
    </td>
</tr>
<tr valign="top">
    <td>Negotiate Workstation Supplied (<tt>0x00002000</tt>)</td>
    <td>
        Indicates that the client is sending its workstation name with the
        message.
    </td>
</tr>
<tr valign="top">
    <td>Negotiate Always Sign (<tt>0x00008000</tt>)</td>
    <td>
        Indicates that communication between the client and server after
        authentication should carry a "dummy" signature.
    </td>
</tr>
<tr valign="top">
    <td>Negotiate NTLM2 Key (<tt>0x00080000</tt>)</td>
    <td>
        Indicates that this client supports the NTLM2 signing and sealing
        scheme; if negotiated, this can also affect the response calculations.
    </td>
</tr>
<tr valign="top">
    <td>Negotiate 128 (<tt>0x20000000</tt>)</td>
    <td>
        Indicates that this client supports strong (128-bit) encryption.
    </td>
</tr>
<tr valign="top">
    <td>Negotiate 56 (<tt>0x80000000</tt>)</td>
    <td>
        Indicates that this client supports medium (56-bit) encryption.
    </td>
</tr>
</table>
<p>
The supplied domain is a security buffer containing the domain in which the
client workstation has membership.  This is always in OEM format, even if
Unicode is supported by the client.
<p>
The supplied workstation is a security buffer containing the client
workstation's name.  This, too, is in OEM rather than Unicode.
<p>
Note that the supplied domain and workstation are optional fields; they may
be empty (security buffer indicating a length of zero), or may not be sent
at all (security buffer omitted altogether).  If the supplied domain and
workstation are omitted, the Type 1 message carries no data block (the
message ends after the flags field, and is a fixed-length 16-byte structure).
The "most-minimal" well-formed Type 1 message, therefore, would be:
<p>
<pre>
    4e544c4d535350000100000002020000
</pre>
<p>
This message contains only the NTLMSSP signature, the NTLM message type, and the
minimal set of flags (Negotiate NTLM and Negotiate OEM).

<a name="type1MessageExample">
<h3>Type 1 Message Example</h3>
<p>
Consider the following hexadecimal Type 1 Message:
<p>
<pre>
    4e544c4d535350000100000007320000060006002b0000000b000b0020000000
    574f524b53544154494f4e444f4d41494e
</pre>
<p>
We break this up as follows:
<p>
<table border="1" cellpadding="5">
<tr valign="top">
    <td align="right">0</td>
    <td align="right"><tt>0x4e544c4d53535000</tt></td><td>NTLMSSP Signature</td>
</tr>
<tr valign="top">
    <td align="right">8</td>
    <td align="right"><tt>0x01000000</tt></td><td>Type 1 Indicator</td>
</tr>
<tr valign="top">
    <td align="right">12</td>
    <td align="right"><tt>0x07320000</tt></td>
    <td>
        Flags:
        <p>
        Negotiate Unicode (<tt>0x00000001</tt>)
        <br>
        Negotiate OEM (<tt>0x00000002</tt>)
        <br>
        Request Target (<tt>0x00000004</tt>)
        <br>
        Negotiate NTLM (<tt>0x00000200</tt>)
        <br>
        Negotiate Domain Supplied (<tt>0x00001000</tt>)
        <br>
        Negotiate Workstation Supplied (<tt>0x00002000</tt>)
    </td>
</tr>
<tr valign="top">
    <td align="right">16</td>
    <td align="right"><tt>0x060006002b000000</tt></td>
    <td>
        Supplied Domain Security Buffer:
        <p>
        Length: 6 bytes (<tt>0x0600</tt>)
        <br>
        Allocated Space: 6 bytes (<tt>0x0600</tt>)
        <br>
        Offset: 43 bytes (<tt>0x2b000000</tt>)
    </td>
</tr>
<tr valign="top">
    <td align="right">24</td>
    <td align="right"><tt>0x0b000b0020000000</tt></td>
    <td>
        Supplied Workstation Security Buffer:
        <p>
        Length: 11 bytes (<tt>0x0b00</tt>)
        <br>
        Allocated Space: 11 bytes (<tt>0x0b00</tt>)
        <br>
        Offset: 32 bytes (<tt>0x20000000</tt>)
    </td>
</tr>
<tr valign="top">
    <td align="right">32</td>
    <td align="right"><tt>0x574f524b53544154494f4e</tt></td>
    <td>Supplied Workstation Data ("<tt>WORKSTATION</tt>")</td>
</tr>
<tr valign="top">
    <td align="right">43</td>
    <td align="right"><tt>0x444f4d41494e</tt></td>
    <td>Supplied Domain Data ("<tt>DOMAIN</tt>")</td>
</tr>
</table>
<p>
Analyzing this information, we can see:
<ul>
<li>
This is an NTLM Type 1 message (from the NTLMSSP Signature and Type 1
Indicator).
</li>
<li>
This client can support either Unicode or OEM strings (the Negotiate Unicode and
Negotiate OEM flags are both set).
</li>
<li>
This client supports NTLM authentication (Negotiate NTLM).
</li>
<li>
The client is requesting that the server send information regarding the
authentication target (Request Target is set).
</li>
<li>
This client is sending its domain, which is "<tt>DOMAIN</tt>"
(the Negotiate Domain Supplied flag is set, and the domain name is present in
the Supplied Domain Security Buffer).
</li>
<li>
The client is sending its workstation name, which is "<tt>WORKSTATION</tt>"
(the Negotiate Workstation Supplied flag is set, and the workstation name is
present in the Supplied Workstation Security Buffer).
</li>
</ul>
<p>
Note that the supplied workstation and domain are in OEM format.  Additionally,
the order in which the security buffer data blocks are laid out is unimportant;
in the example, the workstation data is placed before the domain data.
<p>
After creating the Type 1 message, the client sends it to the server.  The
server analyzes the message, much as we have just done, and creates a reply.
This brings us to our next topic, the Type 2 message.

<a name="theType2Message">
<h2>The Type 2 Message</h2>
<p>
<table cellpadding="5">
<tr valign="top">
    <th align="right"></th><th align="left">Description</th>
    <th align="left">Content</th>
</tr>
<tr valign="top">
    <td align="right">0</td><td>NTLMSSP Signature</td>
    <td>Null-terminated ASCII "NTLMSSP" (<tt>0x4e544c4d53535000</tt>)</td>
</tr>
<tr valign="top">
    <td align="right">8</td><td>NTLM Message Type</td>
    <td><tt>long</tt> (<tt>0x02000000</tt>)</td>
</tr>
<tr valign="top">
    <td align="right">12</td><td>Target Name</td><td>security buffer</td>
</tr>
<tr valign="top">
    <td align="right">20</td><td>Flags</td><td><tt>long</tt></td>
</tr>
<tr valign="top">
    <td align="right">24</td><td>Challenge</td><td>8 bytes</td>
</tr>
<tr valign="top">
    <td align="right"><i>(32)</i></td><td>Context <i>(optional)</i></td>
    <td>8 bytes (two consecutive <tt>long</tt>s)</td>
</tr>
<tr valign="top">
    <td align="right"><i>(40)</i></td><td>Target Information <i>(optional)</i></td>
    <td>security buffer</td>
</tr>
<tr valign="top">
    <td align="right">32 <i>(48)</i></td>
    <td colspan="2"><i>start of data block</i></td>
</tr>
</table>
<p>
The Type 2 message is sent by the server to the client in response to the
client's Type 1 message.  It serves to complete the negotiation of options
with the client, and also provides a challenge to the client.  It may
optionally contain information about the authentication target.
<p>
Typical Type 2 message flags include:
<p>
<table cellpadding="5">
<tr valign="top">
    <td>Negotiate Unicode (<tt>0x00000001</tt>)</td>
    <td>
        The server sets this flag to indicate that it will be using
        Unicode strings.  This should only be set if the client indicates
        (in the Type 1 message) that it supports Unicode.  Either this
        flag or Negotiate OEM should be set, but not both.
    </td>
</tr>
<tr valign="top">
    <td>Negotiate OEM (<tt>0x00000002</tt>)</td>
    <td>
        This flag is set to indicate that the server will be using OEM strings.
        This should only be set if the client indicates (in the Type 1 message)
        that it will support OEM strings.  Either this flag or Negotiate
        Unicode should be set, but not both.
    </td>
</tr>
<tr valign="top">
    <td>Request Target (<tt>0x00000004</tt>)</td>
    <td>
        This flag is often set in the Type 2 message; while it has a
        well-defined meaning within the Type 1 message, its semantics here
        are unclear.
    </td>
</tr>
<tr valign="top">
    <td>Negotiate NTLM (<tt>0x00000200</tt>)</td>
    <td>
        Indicates that NTLM authentication is supported.
    </td>
</tr>
<tr valign="top">
    <td>Negotiate Local Call (<tt>0x00004000</tt>)</td>
    <td>
        The server sets this flag to inform the client that the server and
        client are on the same machine.  The server provides a local
        security context handle with the message.
    </td>
</tr>
<tr valign="top">
    <td>Negotiate Always Sign (<tt>0x00008000</tt>)</td>
    <td>
        Indicates that communication between the client and server after
        authentication should carry a "dummy" signature.
    </td>
</tr>
<tr valign="top">
    <td>Target Type Domain (<tt>0x00010000</tt>)</td>
    <td>
        The server sets this flag to indicate that the authentication target
        is being sent with the message and represents a domain.
    </td>
</tr>
<tr valign="top">
    <td>Target Type Server (<tt>0x00020000</tt>)</td>
    <td>
        The server sets this flag to indicate that the authentication target
        is being sent with the message and represents a server.
    </td>
</tr>
<tr valign="top">
    <td>Target Type Share (<tt>0x00040000</tt>)</td>
    <td>
        The server apparently sets this flag to indicate that the
        authentication target is being sent with the message and represents a
        network share.  This has not been confirmed.
    </td>
</tr>
<tr valign="top">
    <td>Negotiate NTLM2 Key (<tt>0x00080000</tt>)</td>
    <td>
        Indicates that this server supports the NTLM2 signing and sealing
        scheme; if negotiated, this can also affect the client's response
        calculations.
    </td>
</tr>
<tr valign="top">
    <td>Negotiate Target Info (<tt>0x00800000</tt>)</td>
    <td>
        The server sets this flag to indicate that a Target Information block
        is being sent with the message.
    </td>
</tr>
<tr valign="top">
    <td>Negotiate 128 (<tt>0x20000000</tt>)</td>
    <td>
        Indicates that this server supports strong (128-bit) encryption.
    </td>
</tr>
<tr valign="top">
    <td>Negotiate 56 (<tt>0x80000000</tt>)</td>
    <td>
        Indicates that this server supports medium (56-bit) encryption.
    </td>
</tr>
</table>
<p>
The target name is a security buffer containing the name of the authentication
target.  This is typically sent in response to a client requesting the
target (via the Request Target flag in the Type 1 message).  This can contain
a domain, server, or (apparently) a network share.  The target type is
indicated via the Target Type Domain, Target Type Server, and Target Type
Share flags.  The target name can be either Unicode or OEM, as indicated
by the presence of the appropriate flag in the Type 2 message.
<p>
The challenge is an 8-byte block of random data.  The client will use this
to formulate a response.
<p>
The context field is typically populated when Negotiate Local Call is set.
It contains an SSPI context handle, which allows the client to
"short-circuit" authentication and effectively circumvent responding to the
challenge.  Physically, the context is two <tt>long</tt> values.  This is
covered in greater detail later, in the
"<a href='#localAuthentication'>Local Authentication</a>" section.
<p>
The target information is a security buffer containing a Target Information
block, which is used in calculating
<a href="#theNtlmv2Response">the NTLMv2 response</a> (discussed later).  This
is composed of a sequence of subblocks, each consisting of:
<p>
<table border="1" cellpadding="5">
<tr valign="top">
    <th>Field</th><th>Content</th><th>Description</th>
</tr>
<tr valign="top">
    <td>Type</td><td><tt>short</tt></td>
    <td>
        Indicates the type of data in this subblock:
        <table>
        <tr>
            <td>1 (<tt>0x0100</tt>):</td><td>Server name</td>
        </tr>
        <tr>
            <td>2 (<tt>0x0200</tt>):</td><td>Domain name</td>
        </tr>
        <tr>
            <td>3 (<tt>0x0300</tt>):</td>
            <td>
                Fully-qualified DNS host name (i.e., <tt>server.domain.com</tt>)
            </td>
        </tr>
        <tr>
            <td>4 (<tt>0x0400</tt>):</td>
            <td>DNS domain name (i.e., <tt>domain.com</tt>)</td>
        </tr>
        </table>
    </td>
</tr>
<tr valign="top">
    <td>Length</td><td><tt>short</tt></td>
    <td>Length in bytes of this subblock's content field</td>
</tr>
<tr valign="top">
    <td>Content</td><td>Unicode string</td>
    <td>
        Content as indicated by the type field.  Always sent in Unicode,
        even when OEM is indicated by the message flags.
    </td>
</tr>
</table>
<p>
The sequence is terminated by a terminator subblock; this is a subblock
of type "0", of zero length.  Subblocks of type "5" have also been encountered, apparently containing the "parent" DNS domain for servers in subdomains; it
may be that there are other as-yet-unidentified subblock types as well.
<p>
The context and target information may be omitted, in which case the data
block begins at offset 32 (immediately following the challenge).  A minimal
Type 2 message would look something like this:
<p>
<pre>
    4e544c4d53535000020000000000000000000000020200000123456789abcdef
</pre>
<p>
This message contains the NTLMSSP signature, the NTLM message type, an empty
target name, minimal flags (Negotiate NTLM and Negotiate OEM), and the
challenge.

<a name="type2MessageExample">
<h3>Type 2 Message Example</h3>
<p>
Let's look at the following hexadecimal Type 2 Message:
<p>
<pre>
    4e544c4d53535000020000000c000c003000000001028100
    0123456789abcdef0000000000000000620062003c000000
    44004f004d00410049004e0002000c0044004f004d004100
    49004e0001000c0053004500520056004500520004001400
    64006f006d00610069006e002e0063006f006d0003002200
    7300650072007600650072002e0064006f006d0061006900
    6e002e0063006f006d0000000000
</pre>
<p>
Breaking this into its constituent fields gives:
<p>
<table border="1" cellpadding="5">
<tr valign="top">
    <td align="right">0</td>
    <td align="right"><tt>0x4e544c4d53535000</tt></td><td>NTLMSSP Signature</td>
</tr>
<tr valign="top">
    <td align="right">8</td>
    <td align="right"><tt>0x02000000</tt></td><td>Type 2 Indicator</td>
</tr>
<tr valign="top">
    <td align="right">12</td>
    <td align="right"><tt>0x0c000c0030000000</tt></td>
    <td>
        Target Name Security Buffer:
        <p>
        Length: 12 bytes (<tt>0x0c00</tt>)
        <br>
        Allocated Space: 12 bytes (<tt>0x0c00</tt>)
        <br>
        Offset: 48 bytes (<tt>0x30000000</tt>)
    </td>
</tr>
<tr valign="top">
    <td align="right">20</td>
    <td align="right"><tt>0x01028100</tt></td>
    <td>
        Flags:
        <p>
        Negotiate Unicode (<tt>0x00000001</tt>)
        <br>
        Negotiate NTLM (<tt>0x00000200</tt>)
        <br>
        Target Type Domain (<tt>0x00010000</tt>)
        <br>
        Negotiate Target Info (<tt>0x00800000</tt>)
    </td>
</tr>
<tr valign="top">
    <td align="right">24</td>
    <td align="right"><tt>0x0123456789abcdef</tt></td><td>Challenge</td>
</tr>
<tr valign="top">
    <td align="right">32</td>
    <td align="right"><tt>0x0000000000000000</tt></td><td>Context</td>
</tr>
<tr valign="top">
    <td align="right">40</td>
    <td align="right"><tt>0x620062003c000000</tt></td>
    <td>
        Target Information Security Buffer:
        <p>
        Length: 98 bytes (<tt>0x6200</tt>)
        <br>
        Allocated Space: 98 bytes (<tt>0x6200</tt>)
        <br>
        Offset: 60 bytes (<tt>0x3c000000</tt>)
    </td>
</tr>
<tr valign="top">
    <td align="right">48</td>
    <td>
        <pre>0x44004f004d004100
  49004e00</pre>
    </td>
    <td>Target Name Data ("<tt>DOMAIN</tt>")</td>
</tr>
<tr valign="top">
    <td align="right">60</td>
    <td>
        <pre>0x02000c0044004f00
  4d00410049004e00
  01000c0053004500
  5200560045005200
  0400140064006f00
  6d00610069006e00
  2e0063006f006d00
  0300220073006500
  7200760065007200
  2e0064006f006d00
  610069006e002e00
  63006f006d000000
  0000</pre>
    </td>
    <td>
        Target Information Data:
        <p>
        <table border="1" cellpadding="5">
            <tr valign="top">
                <td>
                    <pre>0x02000c0044004f00
  4d00410049004e00</pre>
                </td>
                <td>
                    Domain name subblock:
                    <p>
                    Type: 2 (Domain name, <tt>0x0200</tt>)
                    <br>
                    Length: 12 bytes (<tt>0x0c00</tt>)
                    <br>
                    Data: "<tt>DOMAIN</tt>"
                </td>
            </tr>
            <tr valign="top">
                <td>
                    <pre>0x01000c0053004500
  5200560045005200</pre>
                </td>
                <td>
                    Server name subblock:
                    <p>
                    Type: 1 (Server name, <tt>0x0100</tt>)
                    <br>
                    Length: 12 bytes (<tt>0x0c00</tt>)
                    <br>
                    Data: "<tt>SERVER</tt>"
                </td>
            </tr>
            <tr valign="top">
                <td>
                    <pre>0x0400140064006f00
  6d00610069006e00
  2e0063006f006d00</pre>
                </td>
                <td>
                    DNS domain name subblock:
                    <p>
                    Type: 4 (DNS domain name, <tt>0x0400</tt>)
                    <br>
                    Length: 20 bytes (<tt>0x1400</tt>)
                    <br>
                    Data: "<tt>domain.com</tt>"
                </td>
            </tr>
            <tr valign="top">
                <td>
                    <pre>0x0300220073006500
  7200760065007200
  2e0064006f006d00
  610069006e002e00
  63006f006d00</pre>
                </td>
                <td>
                    DNS server name subblock:
                    <p>
                    Type: 3 (DNS server name, <tt>0x0300</tt>)
                    <br>
                    Length: 34 bytes (<tt>0x2200</tt>)
                    <br>
                    Data: "<tt>server.domain.com</tt>"
                </td>
            </tr>
            <tr valign="top">
                <td align="right"><tt>0x00000000</tt></td>
                <td>
                    Terminator subblock:
                    <p>
                    Type: 0 (terminator, <tt>0x0000</tt>)
                    <br>
                    Length: 0 bytes (<tt>0x0000</tt>)
                </td>
            </tr>
        </table>
    </td>
</tr>
</table>
<p>
An analysis of this message shows:
<ul>
<li>
This is an NTLM Type 2 message (from the NTLMSSP Signature and Type 2
Indicator).
</li>
<li>
The server has indicated that strings will be encoded using Unicode
(the Negotiate Unicode flag is set).
</li>
<li>
The server supports NTLM authentication (Negotiate NTLM).
</li>
<li>
The Target Name provided by the server is populated and represents a domain
(the Target Type Domain flag is set and the domain name is present in the
Target Name Security Buffer).
</li>
<li>
The server is providing a Target Information structure
(Negotiate Target Info is set).  This structure is present in the Target
Information Security Buffer (domain name "<tt>DOMAIN</tt>",
server name "<tt>SERVER</tt>", DNS domain name "<tt>domain.com</tt>",
and DNS server name "<tt>server.domain.com</tt>").
</li>
<li>
The challenge generated by the server is "<tt>0x0123456789abcdef</tt>".
</li>
<li>
An empty context has been sent.
</li>
</ul>
<p>
Note that the target name is in Unicode format (as specified by the Negotiate
Unicode flag).
<p>
After the server creates the Type 2 message, it is sent to the client.
The response to the server's challenge is provided in the client's Type 3
message.

<a name="theType3Message">
<h2>The Type 3 Message</h2>
<p>
<table cellpadding="5">
<tr valign="top">
    <th align="right"></th><th align="left">Description</th>
    <th align="left">Content</th>
</tr>
<tr valign="top">
    <td align="right">0</td><td>NTLMSSP Signature</td>
    <td>Null-terminated ASCII "NTLMSSP" (<tt>0x4e544c4d53535000</tt>)</td>
</tr>
<tr valign="top">
    <td align="right">8</td><td>NTLM Message Type</td>
    <td><tt>long</tt> (<tt>0x03000000</tt>)</td>
</tr>
<tr valign="top">
    <td align="right">12</td><td>LM/LMv2 Response</td>
    <td>security buffer</td>
</tr>
<tr valign="top">
    <td align="right">20</td><td>NTLM/NTLMv2 Response</td>
    <td>security buffer</td>
</tr>
<tr valign="top">
    <td align="right">28</td><td>Domain Name</td>
    <td>security buffer</td>
</tr>
<tr valign="top">
    <td align="right">36</td><td>User Name</td>
    <td>security buffer</td>
</tr>
<tr valign="top">
    <td align="right">44</td><td>Workstation Name</td>
    <td>security buffer</td>
</tr>
<tr valign="top">
    <td align="right"><i>(52)</i></td><td>Session Key <i>(optional)</i></td>
    <td>security buffer</td>
</tr>
<tr valign="top">
    <td align="right"><i>(60)</i></td><td>Flags <i>(optional)</i></td>
    <td><tt>long</tt></td>
</tr>
<tr valign="top">
    <td align="right">52 <i>(64)</i></td>
    <td colspan="2"><i>start of data block</i></td>
</tr>
</table>
<p>
The Type 3 message is the final step in authentication.  This message contains
the client's responses to the Type 2 challenge, which demonstrate
that the client has knowledge of the account password without sending the
password directly.  The Type 3 message also indicates the domain and username
of the authenticating account, as well as the client workstation name.
<p>
Note that the flags in the Type 3 message are optional; older clients include
neither the session key nor the flags in the message.  In this case, the
data block begins at offset 52, immediately following the workstation name
security buffer.  It has been determined experimentally that the Type 3 flags
(when included) do not carry any additional semantics in connection-oriented
authentication; they do not appear to have any discernable effect on either
authentication or the establishment of session security.  Clients sending
flags typically mirror the established Type 2 settings fairly closely.  It is
possible that the flags are sent as a "reminder" of established options, to
allow the server to avoid caching the negotiated settings.  The Type 3 flags
are relevant during
<a href="#datagramAuthentication">datagram-style authentication</a>, however.
<p>
The LM/LMv2 and NTLM/NTLMv2 responses are security buffers containing replies
created from the user's password in response to the Type 2 challenge; the
process for generating these responses is outlined in the next section.
<p>
The domain name is a security buffer containing the authentication realm in
which the authenticating account has membership.  This is either Unicode or
OEM, depending on the negotiated encoding.
<p>
The user name is a security buffer containing the authenticating account name.
This is either Unicode or OEM, depending on the negotiated encoding.
<p>
The workstation name is a security buffer containing the client workstation's
name.  This is either Unicode or OEM, depending on the negotiated encoding.
<p>
The session key value is largely unknown, and is often empty when included;
it is apparently relevant in newer signing and sealing mechanisms.  The Open
Group documentation states that it additionally plays a role in datagram-style
authentication.
<p>
When "Negotiate Local Call" has been established in the Type 2 message, the
security buffers in the Type 3 message are typically all empty (zero length).
The client "adopts" the SSPI context sent in the Type 2 message,
effectively circumventing the need to calculate an appropriate response.

<a name="respondingToTheChallenge">
<h3>Responding to the Challenge</h3>
<p>
The client creates one or more responses to the Type 2 challenge, and sends
these in the Type 3 message.  There are five types of responses:
<ul>
<li>
LM (LAN Manager) Response - Sent by most clients, this is the "original"
response type.
</li>
<li>
NTLM Response - This is sent by NT-based clients, including Windows
2000 and XP.
</li>
<li>
NTLMv2 Response - A newer response type, introduced in Windows NT Service
Pack 4.  This replaces the NTLM response on systems that have NTLM version 2
enabled.
</li>
<li>
LMv2 Response - The replacement for the LM response on NTLM version
2 systems.
</li>
<li>
NTLM2 Session Response - Used when NTLM2 session security is negotiated without
NTLMv2 authentication, this scheme alters the semantics of both the LM and
NTLM responses.
</li>
</ul>
For more detailed information on these schemes, it is highly recommended that
you read Christopher Hertel's
<a href="http://ubiqx.org/cifs"><i>Implementing CIFS</i></a>, especially
<a href="http://ubiqx.org/cifs/SMB.html#SMB.8">the section on authentication</a>.

<a name="theLmResponse">
<h4>The LM Response</h4>
<p>
The LM response is sent by most clients.  This scheme is older than
the NTLM response, and less secure.  While newer clients support the NTLM
response, they typically send both responses for compatibility with legacy
servers; hence, the security flaws present in the LM response are
still exhibited in many clients supporting the NTLM response.
<p>
The LM response is calculated as follows (see <a href="#getLMResponse">Appendix A</a> for a sample implementation in Java):
<ol>
<li>
The user's password (as an OEM string) is converted to uppercase.
</li>
<li>
This password is either null-padded or truncated to 14 bytes.
</li>
<li>
This "fixed" password is split into two 7-byte halves.
</li>
<li>
These values are used to create two DES keys (one from each 7-byte half).
</li>
<li>
Each of these keys is used to DES-encrypt the constant ASCII string
"<tt>KGS!@#$%</tt>" (resulting in two 8-byte ciphertext values).
</li>
<li>
These two ciphertext values are concatenated to form a 16-byte value -
the LM hash.
</li>
<li>
The 16-byte LM hash is null-padded to 21 bytes.
</li>
<li>
This value is split into three 7-byte thirds.
</li>
<li>
These values are used to create three DES keys (one from each 7-byte third).
</li>
<li>
Each of these keys is used to DES-encrypt the challenge from the Type 2 message
(resulting in three 8-byte ciphertext values).
</li>
<li>
These three ciphertext values are concatenated to form a 24-byte value.
This is the LM response.
</li>
</ol>
<p>
This process is best illustrated with a detailed example.  Consider a user
with the password "<tt>SecREt01</tt>", responding to the Type 2 challenge
"<tt>0x0123456789abcdef</tt>".
<ol>
<li>
The password (as an OEM string) is converted to uppercase, giving
"<tt>SECRET01</tt>" (or "<tt>0x5345435245543031</tt>" in hexadecimal).
</li>
<li>
This password is null-padded to 14 bytes, giving
"<tt>0x5345435245543031000000000000</tt>".
</li>
<li>
This value is split into two 7-byte halves, "<tt>0x53454352455430</tt>" and
"<tt>0x31000000000000</tt>".
</li>
<li>
These two values are used to create two DES keys.  A DES key is 8 bytes long;
each byte contains seven bits of key material and one odd-parity bit
(the parity bit may or may not be checked, depending on the underlying DES
implementation).  Our first 7-byte value, "<tt>0x53454352455430</tt>",
would be represented in binary as:
<p>
<tt>01010011 01000101 01000011 01010010 01000101 01010100 00110000</tt>
<p>
A non-parity-adjusted DES key for this value would be:
<p>
<tt>
    0101001<font color="red">0</font> 1010001<font color="red">0</font>
    0101000<font color="red">0</font> 0110101<font color="red">0</font>
    0010010<font color="red">0</font> 0010101<font color="red">0</font>
    0101000<font color="red">0</font> 0110000<font color="red">0</font>
</tt>
<p>
(the parity bits are shown in red above).  This is "<tt>0x52a2506a242a5060</tt>"
in hexadecimal.  Applying odd-parity to ensure that the total number of set
bits in each octet is odd gives:
<p>
<tt>
    0101001<font color="red">0</font> 1010001<font color="red">0</font>
    0101000<font color="red">1</font> 0110101<font color="red">1</font>
    0010010<font color="red">1</font> 0010101<font color="red">0</font>
    0101000<font color="red">1</font> 0110000<font color="red">1</font>
</tt>
<p>
This is the first DES key ("<tt>0x52a2516b252a5161</tt>" in hex).  We then
apply the same process to our second 7-byte value, "<tt>0x31000000000000</tt>",
represented in binary as:
<p>
<tt>00110001 00000000 00000000 00000000 00000000 00000000 00000000</tt>
<p>
Creating a non-parity-adjusted DES key gives:
<p>
<tt>
    0011000<font color="red">0</font> 1000000<font color="red">0</font>
    0000000<font color="red">0</font> 0000000<font color="red">0</font>
    0000000<font color="red">0</font> 0000000<font color="red">0</font>
    0000000<font color="red">0</font> 0000000<font color="red">0</font>
</tt>
<p>
("<tt>0x3080000000000000</tt>" in hexadecimal).  Adjusting the parity bits
gives:
<p>
<tt>
    0011000<font color="red">1</font> 1000000<font color="red">0</font>
    0000000<font color="red">1</font> 0000000<font color="red">1</font>
    0000000<font color="red">1</font> 0000000<font color="red">1</font>
    0000000<font color="red">1</font> 0000000<font color="red">1</font>
</tt>
<p>
This is our second DES key, "<tt>0x3180010101010101</tt>" in hexadecimal.
Note that if our particular DES implementation does not enforce parity
(many do not), the parity-adjustment steps can be skipped; the
non-parity-adjusted values would then be used as the DES keys.  In any
case, the parity bits will not affect the encryption process.
</li>
<li>
Each of our keys is used to DES-encrypt the constant ASCII string
"<tt>KGS!@#$%</tt>" ("<tt>0x4b47532140232425</tt>" in hex).  This gives us
"<tt>0xff3750bcc2b22412</tt>" (using the first key) and
"<tt>0xc2265b23734e0dac</tt>" (using the second).
</li>
<li>
These ciphertext values are concatenated to form our 16-byte LM hash -
"<tt>0xff3750bcc2b22412c2265b23734e0dac</tt>".
</li>
<li>
This is null-padded to 21 bytes, giving
"<tt>0xff3750bcc2b22412c2265b23734e0dac0000000000</tt>".
</li>
<li>
This value is split into three 7-byte thirds, "<tt>0xff3750bcc2b224</tt>",
"<tt>0x12c2265b23734e</tt>" and "<tt>0x0dac0000000000</tt>".
</li>
<li>
These three values are used to create three DES keys.  Using the process
outlined previously, our first value:
<p>
<tt>11111111 00110111 01010000 10111100 11000010 10110010 00100100</tt>
<p>
Gives us the parity-adjusted DES key:
<p>
<tt>
    1111111<font color="red">0</font> 1001101<font color="red">1</font>
    1101010<font color="red">1</font> 0001011<font color="red">0</font>
    1100110<font color="red">1</font> 0001010<font color="red">1</font>
    1100100<font color="red">0</font> 0100100<font color="red">1</font>
</tt>
<p>
("<tt>0xfe9bd516cd15c849</tt>" in hexadecimal).  The second value:
<p>
<tt>00010010 11000010 00100110 01011011 00100011 01110011 01001110</tt>
<p>
Results in the key:
<p>
<tt>
    0001001<font color="red">1</font> 0110000<font color="red">1</font>
    1000100<font color="red">1</font> 1100101<font color="red">1</font>
    1011001<font color="red">1</font> 0001101<font color="red">0</font>
    1100110<font color="red">1</font> 1001110<font color="red">1</font>
</tt>
<p>
("<tt>0x136189cbb31acd9d</tt>").  Finally, the third value:
<p>
<tt>00001101 10101100 00000000 00000000 00000000 00000000 00000000</tt>
<p>
Gives us:
<p>
<tt>
    0000110<font color="red">1</font> 1101011<font color="red">0</font>
    0000000<font color="red">1</font> 0000000<font color="red">1</font>
    0000000<font color="red">1</font> 0000000<font color="red">1</font>
    0000000<font color="red">1</font> 0000000<font color="red">1</font>
</tt>
<p>
This is the third DES key ("<tt>0x0dd6010101010101</tt>").
</li>
<li>
Each of the three keys is used to DES-encrypt the challenge from the Type 2
message (in our example, "<tt>0x0123456789abcdef</tt>").  This gives the
results "<tt>0xc337cd5cbd44fc97</tt>" (using the first key),
"<tt>0x82a667af6d427c6d</tt>" (using the second) and
"<tt>0xe67c20c2d3e77c56</tt>" (using the third).
</li>
<li>
These three ciphertext values are concatenated to form the 24-byte
LM response:
<p>
<tt><b>0xc337cd5cbd44fc9782a667af6d427c6de67c20c2d3e77c56</b></tt>
</li>
</ol>
<p>
There are several weaknesses in this algorithm which make it susceptible to
attack.  While these are covered in detail in the Hertel text, the most
prominent problems are:
<p>
<ul>
<li>
Passwords are converted to upper case before calculating the response.
This significantly reduces the set of possible passwords that must be tested
in a brute-force attack.
</li>
<li>
If the password is seven or fewer characters, the second value from step 3
above will be 7 null bytes.  This effectively compromises half of the
LM hash (as it will always be the ciphertext of "<tt>KGS!@#$%</tt>"
encrypted with the DES key "<tt>0x0101010101010101</tt>" - the constant
"<tt>0xaad3b435b51404ee</tt>").  This in turn compromises the three DES keys
used to produce the response; the entire third key and all but one byte of the
second will be known constant values.
</li>
</ul>

<a name="theNtlmResponse">
<h4>The NTLM Response</h4>
<p>
The NTLM response is sent by newer clients.  This scheme addresses some of the
flaws in the LM response; however, it is still considered fairly
weak.  Additionally, the NTLM response is nearly always sent in conjunction with
the LM response.  The weaknesses in that algorithm can be exploited
to obtain the case-insensitive password, and trial-and-error used to find
the case-sensitive password employed by the NTLM response.
<p>
The NTLM response is calculated as follows (see <a href="#getNTLMResponse">Appendix A</a> for a sample Java implementation):
<ol>
<li>
The MD4 message-digest algorithm (described in
<a href="http://www.ietf.org/rfc/rfc1320.txt">RFC 1320</a>) is applied to the
Unicode mixed-case password.  This results in a 16-byte value - the NTLM hash.
</li>
<li>
The 16-byte NTLM hash is null-padded to 21 bytes.
</li>
<li>
This value is split into three 7-byte thirds.
</li>
<li>
These values are used to create three DES keys (one from each 7-byte third).
</li>
<li>
Each of these keys is used to DES-encrypt the challenge from the Type 2
message (resulting in three 8-byte ciphertext values).
</li>
<li>
These three ciphertext values are concatenated to form a 24-byte value.
This is the NTLM response.
</li>
</ol>
<p>
Note that only the calculation of the hash value differs from the LM
scheme; the response calculation is the same.  To illustrate this
process, we will apply it to our previous example (a user with the password
"<tt>SecREt01</tt>", responding to the Type 2 challenge
"<tt>0x0123456789abcdef</tt>").
<ol>
<li>
The Unicode mixed-case password is "<tt>0x53006500630052004500740030003100</tt>"
in hexadecimal; the MD4 hash of this value is calculated, giving
"<tt>0xcd06ca7c7e10c99b1d33b7485a2ed808</tt>".  This is the NTLM hash.
</li>
<li>
This is null-padded to 21 bytes, giving
"<tt>0xcd06ca7c7e10c99b1d33b7485a2ed8080000000000</tt>".
</li>
<li>
This value is split into three 7-byte thirds, "<tt>0xcd06ca7c7e10c9</tt>",
"<tt>0x9b1d33b7485a2e</tt>" and "<tt>0xd8080000000000</tt>".
</li>
<li>
These three values are used to create three DES keys.  Our first value:
<p>
<tt>11001101 00000110 11001010 01111100 01111110 00010000 11001001</tt>
<p>
Results in the parity-adjusted key:
<p>
<tt>
    1100110<font color="red">1</font> 1000001<font color="red">1</font>
    1011001<font color="red">1</font> 0100111<font color="red">1</font>
    1100011<font color="red">1</font> 1111000<font color="red">1</font>
    0100001<font color="red">1</font> 1001001<font color="red">0</font>
</tt>
<p>
("<tt>0xcd83b34fc7f14392</tt>" in hexadecimal).  The second value:
<p>
<tt>10011011 00011101 00110011 10110111 01001000 01011010 00101110</tt>
<p>
Gives the key:
<p>
<tt>
    1001101<font color="red">1</font> 1000111<font color="red">1</font>
    0100110<font color="red">0</font> 0111011<font color="red">0</font>
    0111010<font color="red">1</font> 0100001<font color="red">1</font>
    0110100<font color="red">0</font> 0101110<font color="red">1</font>
</tt>
<p>
("<tt>0x9b8f4c767543685d</tt>").  Our third value:
<p>
<tt>11011000 00001000 00000000 00000000 00000000 00000000 00000000</tt>
<p>
Yields our third key:
<p>
<tt>
    1101100<font color="red">1</font> 0000010<font color="red">0</font>
    0000000<font color="red">1</font> 0000000<font color="red">1</font>
    0000000<font color="red">1</font> 0000000<font color="red">1</font>
    0000000<font color="red">1</font> 0000000<font color="red">1</font>
</tt>
<p>
("<tt>0xd904010101010101</tt>" in hexadecimal).
</li>
<li>
Each of the three keys is used to DES-encrypt the challenge from the Type 2
message ("<tt>0x0123456789abcdef</tt>").  This yields the results
"<tt>0x25a98c1c31e81847</tt>" (using our first key),
"<tt>0x466b29b2df4680f3</tt>" (using the second) and
"<tt>0x9958fb8c213a9cc6</tt>" (using the third key).
</li>
<li>
These three ciphertext values are concatenated to form the 24-byte NTLM
response:
<p>
<tt><b>0x25a98c1c31e81847466b29b2df4680f39958fb8c213a9cc6</b></tt>
</li>
</ol>

<a name="theNtlmv2Response">
<h4>The NTLMv2 Response</h4>
<p>
NTLM version 2 ("NTLMv2") was concocted to address the security issues
present in NTLM.  While its effectiveness in this regard is questionable, it
does at least provide a more secure replacement for the LM response.
When NTLMv2 is enabled, the NTLM response is replaced with the NTLMv2 response,
and the LM response is replaced with the LMv2 response (which we
will discuss next).
<p>
The NTLMv2 response is calculated as follows (see <a href="#getNTLMv2Response">Appendix A</a> for a sample implementation in Java):
<ol>
<li>
The NTLM password hash is obtained (as discussed previously, this is the
MD4 digest of the Unicode mixed-case password).
</li>
<li>
The Unicode uppercase username is concatenated with the Unicode uppercase
authentication target (domain or server name).  The HMAC-MD5 message
authentication code algorithm (described in
<a href="http://www.ietf.org/rfc/rfc2104.txt">RFC 2104</a>) is applied to this
value using the 16-byte NTLM hash as the key.  This results in a 16-byte
value - the NTLMv2 hash.
</li>
<li>
A block of data known as the "blob" is constructed.  The Hertel text discusses
the format of this structure in greater detail; briefly:
<table cellpadding="5">
<tr valign="top">
    <th align="right"></th><th align="left">Description</th>
    <th align="left">Content</th>
</tr>
<tr valign="top">
    <td align="right">0</td><td>Blob Signature</td>
    <td><tt>0x01010000</tt></td>
</tr>
<tr valign="top">
    <td align="right">4</td><td>Reserved</td>
    <td><tt>long</tt> (<tt>0x00000000</tt>)</td>
</tr>
<tr valign="top">
    <td align="right">8</td><td>Timestamp</td>
    <td>
        Little-endian, 64-bit signed value representing the number of tenths
        of a microsecond since January 1, 1601.
    </td>
</tr>
<tr valign="top">
    <td align="right">16</td><td>Client Challenge</td><td>8 bytes</td>
</tr>
<tr valign="top">
    <td align="right">24</td><td>Unknown</td><td>4 bytes</td>
</tr>
<tr valign="top">
    <td align="right">28</td><td>Target Information</td>
    <td>Target Information block (from the Type 2 message).</td>
</tr>
<tr valign="top">
    <td align="right"><i>(variable)</i></td><td>Unknown</td>
    <td>4 bytes</td>
</tr>
</table>
</li>
<li>
The challenge from the Type 2 message is concatenated with the blob.
The HMAC-MD5 message authentication code algorithm is applied to this value
using the 16-byte NTLMv2 hash (calculated in step 2) as the key.  This
results in a 16-byte output value.
</li>
<li>
This value is concatenated with the blob to form the NTLMv2 response.
</li>
</ol>
<p>
Let's look at an example.  Since we need a bit more information to calculate
the NTLMv2 response, we will use the following values from the examples
presented previously:
<p>
<table cellpadding="5">
<tr valign="top">
    <td align="right">Domain:</td>
    <td><tt>DOMAIN</tt></td>
</tr>
<tr valign="top">
    <td align="right">Username:</td>
    <td><tt>user</tt></td>
</tr>
<tr valign="top">
    <td align="right">Password:</td>
    <td><tt>SecREt01</tt></td>
</tr>
<tr valign="top">
    <td align="right">Challenge:</td>
    <td><tt>0x0123456789abcdef</tt></td>
</tr>
<tr valign="top">
    <td align="right">Target Information:</td>
    <td>
        <pre>0x02000c0044004f00
  4d00410049004e00
  01000c0053004500
  5200560045005200
  0400140064006f00
  6d00610069006e00
  2e0063006f006d00
  0300220073006500
  7200760065007200
  2e0064006f006d00
  610069006e002e00
  63006f006d000000
  0000</pre>
    </td>
</tr>
</table>
<ol>
<li>
The Unicode mixed-case password is "<tt>0x53006500630052004500740030003100</tt>"
in hexadecimal; the MD4 hash of this value is calculated, giving
"<tt>0xcd06ca7c7e10c99b1d33b7485a2ed808</tt>".  This is the NTLM hash.
</li>
<li>
The Unicode uppercase username is concatenated with the Unicode uppercase
authentication target, giving "<tt>USERDOMAIN</tt>" (or
"<tt>0x550053004500520044004f004d00410049004e00</tt>" in hexadecimal).
HMAC-MD5 is applied to this value using the 16-byte NTLM hash from the
previous step as the key, which yields
"<tt>0x04b8e0ba74289cc540826bab1dee63ae</tt>".  This is the NTLMv2 hash.
</li>
<li>
Next, the blob is constructed.  The timestamp is the most tedious part of
this; looking at the clock on my desk, it's about 6:00 AM EDT on June 17th,
2003.  In Unix time, that would be 1055844000 seconds after the Epoch.
Adding 11644473600 will give us seconds after January 1, 1601 (12700317600).
Multiplying by 10<sup>7</sup> (10000000) will give us tenths of a microsecond
(127003176000000000).  As a little-endian 64-bit value, this is
"<tt>0x0090d336b734c301</tt>" (in hexadecimal).
<p>
We also need to generate an 8-byte random "client challenge"; we will use the
not-so-random "<tt>0xffffff0011223344</tt>".  Constructing the rest of the
blob is easy; we just concatenate:
<p>
<table cellpadding="5">
<tr valign="top">
    <td><tt>0x01010000</tt></td><td>(the blob signature)</td>
</tr>
<tr valign="top">
    <td><tt>0x00000000</tt></td><td>(reserved value)</td>
</tr>
<tr valign="top">
    <td><tt>0x0090d336b734c301</tt></td><td>(our timestamp)</td>
</tr>
<tr valign="top">
    <td><tt>0xffffff0011223344</tt></td><td>(a random client challenge)</td>
</tr>
<tr valign="top">
    <td><tt>0x00000000</tt></td><td>(unknown, but zero will work)</td>
</tr>
<tr valign="top">
    <td>
        <pre>0x02000c0044004f00
  4d00410049004e00
  01000c0053004500
  5200560045005200
  0400140064006f00
  6d00610069006e00
  2e0063006f006d00
  0300220073006500
  7200760065007200
  2e0064006f006d00
  610069006e002e00
  63006f006d000000
  0000</pre>
    </td>
    <td>(our target information block)</td>
</tr>
<tr valign="top">
    <td><tt>0x00000000</tt></td><td>(unknown, but zero will work)</td>
</tr>
</table>
</li>
<li>
We then concatenate the Type 2 challenge with our blob:
<pre>
0x0123456789abcdef0101000000000000
  0090d336b734c301ffffff0011223344
  0000000002000c0044004f004d004100
  49004e0001000c005300450052005600
  450052000400140064006f006d006100
  69006e002e0063006f006d0003002200
  7300650072007600650072002e006400
  6f006d00610069006e002e0063006f00
  6d000000000000000000
</pre>
<p>
Applying HMAC-MD5 to this value using the NTLMv2 hash from step 2 as the key
gives us the 16-byte value "<tt>0xcbabbca713eb795d04c97abc01ee4983</tt>".
</li>
<li>
This value is concatenated with the blob to obtain the NTLMv2 response:
<pre>
<b>0xcbabbca713eb795d04c97abc01ee4983
  01010000000000000090d336b734c301
  ffffff00112233440000000002000c00
  44004f004d00410049004e0001000c00
  53004500520056004500520004001400
  64006f006d00610069006e002e006300
  6f006d00030022007300650072007600
  650072002e0064006f006d0061006900
  6e002e0063006f006d00000000000000
  0000</b>
</pre>
</li>
</ol>

<a name="theLmv2Response">
<h4>The LMv2 Response</h4>
<p>
The LMv2 response is used to provide pass-through authentication compatibility
with older servers.  It is quite possible that the server with which the
client is communicating will not actually perform the authentication; rather,
it will pass the responses through to a domain controller for verification.
Older servers pass only the LM response, and expect it to be exactly 24 bytes.
The LMv2 response was designed to allow such servers to operate properly;
it is effectively a "miniature" NTLMv2 response, obtained as follows
(see <a href="#getLMv2Response">Appendix A</a> for a sample Java
implementation):
<ol>
<li>
The NTLM password hash is calculated (the MD4 digest of the Unicode mixed-case
password).
</li>
<li>
The Unicode uppercase username is concatenated with the Unicode uppercase
authentication target (domain or server name).  The HMAC-MD5 message
authentication code algorithm is applied to this value using the 16-byte
NTLM hash as the key.  This results in a 16-byte value - the NTLMv2 hash.
</li>
<li>
A random 8-byte client challenge is created (this is the same client challenge
used in the NTLMv2 blob).
</li>
<li>
The challenge from the Type 2 message is concatenated with the client
challenge.  The HMAC-MD5 message authentication code algorithm is applied to
this value using the 16-byte NTLMv2 hash (calculated in step 2) as the key.
This results in a 16-byte output value.
</li>
<li>
This value is concatenated with the 8-byte client challenge to form the
24-byte LMv2 response.
</li>
</ol>
<p>
We will illustrate this process with a brief example using our tried-and-true
sample values:
<p>
<table cellpadding="5">
<tr valign="top">
    <td align="right">Domain:</td>
    <td><tt>DOMAIN</tt></td>
</tr>
<tr valign="top">
    <td align="right">Username:</td>
    <td><tt>user</tt></td>
</tr>
<tr valign="top">
    <td align="right">Password:</td>
    <td><tt>SecREt01</tt></td>
</tr>
<tr valign="top">
    <td align="right">Challenge:</td>
    <td><tt>0x0123456789abcdef</tt></td>
</tr>
</table>
<ol>
<li>
The Unicode mixed-case password is "<tt>0x53006500630052004500740030003100</tt>"
in hexadecimal; the MD4 hash of this value is calculated, giving
"<tt>0xcd06ca7c7e10c99b1d33b7485a2ed808</tt>".  This is the NTLM hash.
</li>
<li>
The Unicode uppercase username is concatenated with the Unicode uppercase
authentication target, giving "<tt>USERDOMAIN</tt>" (or
"<tt>0x550053004500520044004f004d00410049004e00</tt>" in hexadecimal).
HMAC-MD5 is applied to this value using the 16-byte NTLM hash from the
previous step as the key, which yields
"<tt>0x04b8e0ba74289cc540826bab1dee63ae</tt>".  This is the NTLMv2 hash.
</li>
<li>
A random 8-byte client challenge is created.  From our NTLMv2 example, we will
use "<tt>0xffffff0011223344</tt>".
</li>
<li>
We then concatenate the Type 2 challenge with our client challenge:
<p>
<tt>0x0123456789abcdefffffff0011223344</tt>
<p>
Applying HMAC-MD5 to this value using the NTLMv2 hash from step 2 as the key
gives us the 16-byte value "<tt>0xd6e6152ea25d03b7c6ba6629c2d6aaf0</tt>".
</li>
<li>
This value is concatenated with the client challenge to obtain the 24-byte
LMv2 response:
<p>
<tt><b>0xd6e6152ea25d03b7c6ba6629c2d6aaf0ffffff0011223344</b></tt>
</li>
</ol>

<a name="theNtlm2SessionResponse">
<h4>The NTLM2 Session Response</h4>
<p>
The NTLM2 session response can be employed in conjunction with NTLM2 session
security (it is made available with the "Negotiate NTLM2 Key" flag).  This
is used to provide enhanced protection against precomputed dictionary attacks
in environments which do not support NTLMv2 authentication.
<p>
The calculation of the NTLM2 session response is similar to the NTLM response;
it effectively replaces both the LM and NTLM response fields as follows
(see <a href="#getNTLM2SessionResponse">Appendix A</a> for a sample
implementation in Java):
<ol>
<li>
A random 8-byte client challenge is created.
</li>
<li>
The client challenge is null-padded to 24 bytes.  This value is placed in
the LM response field of the Type 3 message.
</li>
<li>
The challenge from the Type 2 message is concatenated with the 8-byte client
challenge to form a session nonce.
</li>
<li>
The MD5 message-digest algorithm (described in
<a href="http://www.ietf.org/rfc/rfc1321.txt">RFC 1321</a>) is applied to
the session nonce, resulting in a 16-byte value.
</li>
<li>
This value is truncated to 8 bytes to form the NTLM2 session hash.
</li>
<li>
The NTLM password hash is obtained (as discussed, this is the MD4 digest of the
Unicode mixed-case password).
</li>
<li>
The 16-byte NTLM hash is null-padded to 21 bytes.
</li>
<li>
This value is split into three 7-byte thirds.
</li>
<li>
These values are used to create three DES keys (one from each 7-byte third).
</li>
<li>
Each of these keys is used to DES-encrypt the NTLM2 session hash (resulting
in three 8-byte ciphertext values).
</li>
<li>
These three ciphertext values are concatenated to form a 24-byte value.  This
is the NTLM2 session response, which is placed in the NTLM response field of
the Type 3 message.
</li>
</ol>
<p>
To demonstrate this with our previous example values (a user with the password
"<tt>SecREt01</tt>", responding to the Type 2 challenge
"<tt>0x0123456789abcdef</tt>"):
<ol>
<li>
A random 8-byte client challenge is created; we will use
"<tt>0xffffff0011223344</tt>", as in the previous examples.
</li>
<li>
The challenge is null-padded to 24 bytes:
<p>
<tt><b>0xffffff001122334400000000000000000000000000000000</b></tt>
<p>
This value is placed in the LM response field of the Type 3 message.
</li>
<li>
The challenge from the Type 2 message is concatenated with the client
challenge, forming a session nonce
("<tt>0x0123456789abcdefffffff0011223344</tt>").
</li>
<li>
Applying the MD5 digest to this nonce yields the 16-byte value
"<tt>0xbeac9a1bc5a9867c15192b3105d5beb1</tt>".
</li>
<li>
This is truncated to 8 bytes to obtain the NTLM2 session hash
("<tt>0xbeac9a1bc5a9867c</tt>").
</li>
<li>
The Unicode mixed-case password is
"<tt>0x53006500630052004500740030003100</tt>";  applying the MD4 digest to
this value gives us the NTLM hash
("<tt>0xcd06ca7c7e10c99b1d33b7485a2ed808</tt>").
</li>
<li>
This is null-padded to 21 bytes, giving
"<tt>0xcd06ca7c7e10c99b1d33b7485a2ed8080000000000</tt>".
</li>
<li>
This value is split into three 7-byte thirds, "<tt>0xcd06ca7c7e10c9</tt>",
"<tt>0x9b1d33b7485a2e</tt>" and "<tt>0xd8080000000000</tt>".
</li>
<li>
These values are used to create three DES keys (as calculated in our previous
NTLM response example, "<tt>0xcd83b34fc7f14392</tt>",
"<tt>0x9b8f4c767543685d</tt>", and "<tt>0xd904010101010101</tt>").
</li>
<li>
Each of these three keys is used to DES-encrypt the NTLM2 session hash
("<tt>0xbeac9a1bc5a9867c</tt>").  This yields the results
"<tt>0x10d550832d12b2cc</tt>" (using our first key),
"<tt>0xb79d5ad1f4eed3df</tt>" (using the second), and
"<tt>0x82aca4c3681dd455</tt>" (using the third key).
</li>
<li>
These three ciphertext values are concatenated to form the 24-byte
NTLM2 session response:
<p>
<tt><b>0x10d550832d12b2ccb79d5ad1f4eed3df82aca4c3681dd455</b></tt>
<p>
which is placed in the NTLM response field of the Type 3 message.
</li>
</ol>

<a name="type3MessageExample">
<h3>Type 3 Message Example</h3>
<p>
Now that we're familiar with the Type 3 responses, we are ready to examine a
Type 3 Message:
<p>
<pre>
    4e544c4d5353500003000000180018006a00000018001800
    820000000c000c0040000000080008004c00000016001600
    54000000000000009a0000000102000044004f004d004100
    49004e00750073006500720057004f0052004b0053005400
    4100540049004f004e00c337cd5cbd44fc9782a667af6d42
    7c6de67c20c2d3e77c5625a98c1c31e81847466b29b2df46
    80f39958fb8c213a9cc6
</pre>
<p>
This message is decomposed as:
<p>
<table border="1" cellpadding="5">
<tr valign="top">
    <td align="right">0</td>
    <td align="right"><tt>0x4e544c4d53535000</tt></td><td>NTLMSSP Signature</td>
</tr>
<tr valign="top">
    <td align="right">8</td>
    <td align="right"><tt>0x03000000</tt></td><td>Type 3 Indicator</td>
</tr>
<tr valign="top">
    <td align="right">12</td>
    <td align="right"><tt>0x180018006a000000</tt></td>
    <td>
        LM Response Security Buffer:
        <p>
        Length: 24 bytes (<tt>0x1800</tt>)
        <br>
        Allocated Space: 24 bytes (<tt>0x1800</tt>)
        <br>
        Offset: 106 bytes (<tt>0x6a000000</tt>)
    </td>
</tr>
<tr valign="top">
    <td align="right">20</td>
    <td align="right"><tt>0x1800180082000000</tt></td>
    <td>
        NTLM Response Security Buffer:
        <p>
        Length: 24 bytes (<tt>0x1800</tt>)
        <br>
        Allocated Space: 24 bytes (<tt>0x1800</tt>)
        <br>
        Offset: 130 bytes (<tt>0x82000000</tt>)
    </td>
</tr>
<tr valign="top">
    <td align="right">28</td>
    <td align="right"><tt>0x0c000c0040000000</tt></td>
    <td>
        Domain Name Security Buffer:
        <p>
        Length: 12 bytes (<tt>0x0c00</tt>)
        <br>
        Allocated Space: 12 bytes (<tt>0x0c00</tt>)
        <br>
        Offset: 64 bytes (<tt>0x40000000</tt>)
    </td>
</tr>
<tr valign="top">
    <td align="right">36</td>
    <td align="right"><tt>0x080008004c000000</tt></td>
    <td>
        User Name Security Buffer:
        <p>
        Length: 8 bytes (<tt>0x0800</tt>)
        <br>
        Allocated Space: 8 bytes (<tt>0x0800</tt>)
        <br>
        Offset: 76 bytes (<tt>0x4c000000</tt>)
    </td>
</tr>
<tr valign="top">
    <td align="right">44</td>
    <td align="right"><tt>0x1600160054000000</tt></td>
    <td>
        Workstation Name Security Buffer:
        <p>
        Length: 22 bytes (<tt>0x1600</tt>)
        <br>
        Allocated Space: 22 bytes (<tt>0x1600</tt>)
        <br>
        Offset: 84 bytes (<tt>0x54000000</tt>)
    </td>
</tr>
<tr valign="top">
    <td align="right">52</td>
    <td align="right"><tt>0x000000009a000000</tt></td>
    <td>
        Session Key Security Buffer:
        <p>
        Length: 0 bytes (<tt>0x0000</tt>)
        <br>
        Allocated Space: 0 bytes (<tt>0x0000</tt>)
        <br>
        Offset: 154 bytes (<tt>0x9a000000</tt>)
    </td>
</tr>
<tr valign="top">
    <td align="right">60</td>
    <td align="right"><tt>0x01020000</tt></td>
    <td>
        Flags:
        <p>
        Negotiate Unicode (<tt>0x00000001</tt>)
        <br>
        Negotiate NTLM (<tt>0x00000200</tt>)
    </td>
</tr>
<tr valign="top">
    <td align="right">64</td>
    <td>
        <pre>0x44004f004d004100
  49004e00</pre>
    </td>
    <td>Domain Name Data ("<tt>DOMAIN</tt>")</td>
</tr>
<tr valign="top">
    <td align="right">76</td>
    <td align="right"><tt>0x7500730065007200</tt></td>
    <td>User Name Data ("<tt>user</tt>")</td>
</tr>
<tr valign="top">
    <td align="right">84</td>
    <td>
        <pre>0x57004f0052004b00
  5300540041005400
  49004f004e00</pre>
    </td>
    <td>Workstation Name Data ("<tt>WORKSTATION</tt>")</td>
</tr>
<tr valign="top">
    <td align="right">106</td>
    <td>
        <pre>0xc337cd5cbd44fc97
  82a667af6d427c6d
  e67c20c2d3e77c56</pre>
    </td>
    <td>LM Response Data</td>
</tr>
<tr valign="top">
    <td align="right">130</td>
    <td>
        <pre>0x25a98c1c31e81847
  466b29b2df4680f3
  9958fb8c213a9cc6</pre>
    </td>
    <td>NTLM Response Data</td>
</tr>
</table>
<p>
Analysis of this reveals:
<ul>
<li>
This is an NTLM Type 3 message (from the NTLMSSP Signature and Type 3
Indicator).
</li>
<li>
The client has indicated that strings are encoded using Unicode
(the Negotiate Unicode flag is set).
</li>
<li>
The client supports NTLM authentication (Negotiate NTLM).
</li>
<li>
The client's domain is "<tt>DOMAIN</tt>".
</li>
<li>
The client's username is "<tt>user</tt>".
</li>
<li>
The client's workstation is "<tt>WORKSTATION</tt>".
</li>
<li>
The client's LM response is
"<tt>0xc337cd5cbd44fc9782a667af6d427c6de67c20c2d3e77c56</tt>".
</li>
<li>
The client's NTLM response is
"<tt>0x25a98c1c31e81847466b29b2df4680f39958fb8c213a9cc6</tt>".
</li>
<li>
An empty session key has been sent.
</li>
</ul>
<p>
Upon receipt of the Type 3 message, the server calculates the LM and
NTLM responses and compares them to the values provided by the client; if they
match, the user is successfully authenticated.

<a name="ntlmVersion2">
<h2>NTLM Version 2</h2>
<p>
NTLM version 2 consists of three new response algorithms (NTLMv2, LMv2, 
and the NTLM2 session response, discussed previously) and a new signing and
sealing scheme (NTLM2 session security).  NTLM2 session security is negotiated
via the "Negotiate NTLM2 Key" flag; NTLMv2 authentication, however, is enabled
through a modification to the registry.  Further, the registry setting on the
client and server must be compatible in order for authentication to be
successful. The result is that the overwhelming majority of hosts just use the
default setting, and NTLMv2 authentication is rarely seen in deployed systems.
<p>
Instructions for enabling NTLM version 2 are detailed in
 <a href="http://support.microsoft.com/default.aspx?scid=KB;en-us;239869">Microsoft Knowledge Base Article 239869</a>; briefly, a modification is made to the
 registy value:
<pre>
    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\LSA\LMCompatibilityLevel
</pre>
<p>
(<tt>LMCompatibility</tt> on Win9x-based systems).  This is a
 <tt>REG_DWORD</tt> entry, and can be set to one of the following values:
<p>
<table cellpadding="3" border="1">
<tr valign="top">
    <th>Level</th><th>Sent by Client</th><th>Accepted by Server</th>
</tr>
<tr valign="top">
    <td>0</td>
    <td>
        LM
        <br>
        NTLM
    </td>
    <td>
        LM
        <br>
        NTLM
        <br>
        LMv2
        <br>
        NTLMv2
    </td>
</tr>
<tr valign="top">
    <td>1</td>
    <td>
        LM
        <br>
        NTLM
    </td>
    <td>
        LM
        <br>
        NTLM
        <br>
        LMv2
        <br>
        NTLMv2
    </td>
</tr>
<tr valign="top">
    <td>2</td>
    <td>
        NTLM
    </td>
    <td>
        LM
        <br>
        NTLM
        <br>
        LMv2
        <br>
        NTLMv2
    </td>
</tr>
<tr valign="top">
    <td>3</td>
    <td>
        LMv2
        <br>
        NTLMv2
    </td>
    <td>
        LM
        <br>
        NTLM
        <br>
        LMv2
        <br>
        NTLMv2
    </td>
</tr>
<tr valign="top">
    <td>4</td>
    <td>
        LMv2
        <br>
        NTLMv2
    </td>
    <td>
        NTLM
        <br>
        LMv2
        <br>
        NTLMv2
    </td>
</tr>
<tr valign="top">
    <td>5</td>
    <td>
        LMv2
        <br>
        NTLMv2
    </td>
    <td>
        LMv2
        <br>
        NTLMv2
    </td>
</tr>
</table>
<p>
In Levels 1 and higher, NTLM2 session security is supported.  Only Levels
0 and 3 are available on Win9x-based systems (Windows 95, Windows 98, and
Windows ME); these platforms do not support the NTLM response, and instead
send only the LM response in the Type 3 message.  In Level 2, clients send the
NTLM response twice (in both the LM and NTLM response fields).  At Level 3 and
higher, the LMv2 and NTLMv2 responses replace the LM and NTLM responses,
respectively.
<p>
When NTLM2 session security has been negotiated (indicated by the "Negotiate
NTLM2 Key" flag), the NTLM2 session response can be used in Levels 0, 1, and
2 as a replacement for the weaker LM and NTLM responses.  This offers
heightened protection against server-based precomputed dictionary attacks;
the client's response to a given challenge is made variable by adding a
random client nonce to the calculation.

<a name="ntlmsspAndSspi">
<h2>NTLMSSP and SSPI</h2>
<p>
Now that we have a working knowledge of NTLM authentication, it is appropriate
 to look at how NTLM fits into the "big picture".
<p>
Windows provides an authentication framework known as SSPI - the Security Support Provider interface.  This is the Microsoft equivalent of the GSS-API
(Generic Security Service Application Program Interface,
<a href="http://www.ietf.org/rfc/rfc2743.txt">RFC 2743</a>), and allows for a
very high-level, mechanism-independent means of authentication.  SSPI supports
several underlying providers.  One of these is the NTLMSSP (NTLM Security
Support Provider), which provides the NTLM authentication mechanism we have
been discussing thus far.  SSPI supplies a flexible API for handling opaque,
provider-specific authentication tokens; the NTLM Type 1, Type 2, and Type 3
messages are such tokens, specific to and processed by the NTLMSSP.  The API
provided by SSPI abstracts away all the details of NTLM; the application
developer doesn't even have to be aware that NTLM is being used, and another
authentication mechanism (such as Kerberos) can be swapped in with little or
no changes at the application level.
<p>
We aren't going to go into the details of SSPI, but we will briefly outline
the SSPI authentication handshake as applied to NTLM:
<p>
<ol>
<li>
The client obtains a representation of the credential set for the user via the
 SSPI <tt>AcquireCredentialsHandle</tt> function.
</li>
<li>
The client calls the SSPI <tt>InitializeSecurityContext</tt> function to
obtain an authentication request token (in our case, a Type 1 message).
The client sends this token to the server.  The return value from
the function indicates that authentication will require multiple steps.
</li>
<li>
The server receives the token from the client, and uses it as input to the
<tt>AcceptSecurityContext</tt> SSPI function.  This creates a local security
 context on the server to represent the client, and yields an authentication
response token (the Type 2 message), which is sent to the client.  The
 return value from the function indicates that further information
 is needed from the client.
</li>
<li>
The client receives the response token from the server and calls
<tt>InitializeSecurityContext</tt> again, passing the server's token as
input.  This provides us with another authentication request token
 (the Type 3 message).  The return value indicates that the security context
was successfully initialized; the token is sent to the server.
</li>
<li>
The server receives the token from the client and calls
<tt>AcceptSecurityContext</tt> again, using the Type 3 message as input.
The return value indicates the context was successfully accepted; no token
is produced, and authentication is complete.
</li>
</ol>

<a name="localAuthentication">
<h3>Local Authentication</h3>
<p>
We have alluded to the local authentication sequence at various points in
our discussion; having a basic understanding of SSPI, we can look at this
scenario in more detail.
<p>
Local authentication is negotiated through a series of decisions made by the
client and server, based on the information in the NTLM messages.  It works as
follows:
<p>
<ol>
<li>
The client calls the <tt>AcquireCredentialsHandle</tt> function, specifying the
default credentials by passing in null to the "pAuthData" parameter.  This
obtains a handle to the credentials of the logged in user for single sign-on.
</li>
<li>
The client calls the SSPI <tt>InitializeSecurityContext</tt> function to
create the Type 1 message.  When the default credential handle is supplied,
the Type 1 message contains the workstation and domain name of the client.
This is indicated by the presence of the "Negotiate Domain Supplied" and
"Negotiate Workstation Supplied" flags, and the inclusion of populated
Supplied Domain and Supplied Workstation security buffers in the message.
</li>
<li>
The server receives the Type 1 message from the client, and calls
<tt>AcceptSecurityContext</tt>.  This creates a local security
 context on the server to represent the client.  The server examines the domain
and workstation information sent by the client to determine if the client and
server are the same machine.  If so, the server initiates local authentication
by setting the "Negotiate Local Call" flag in the resultant Type 2 message.
The first <tt>long</tt> in the Context field of the Type 2 message is
populated with the "upper" portion of the newly obtained SSPI context handle
(specifically, the "dwUpper" field of the SSPI <tt>CtxtHandle</tt> structure).
The second <tt>long</tt> in the Context field appears to be empty in all
cases. (although logically one would assume it should contain the "lower"
portion of the context handle).
</li>
<li>
The client receives the Type 2 message from the server and passes it to
<tt>InitializeSecurityContext</tt>.  Having noted the presence of the
"Negotiate Local Call" flag, the client examines the server context handle
to determine if it represents a valid local security context.  If the context
cannot be validated, authentication proceeds as usual - the appropriate
responses are calculated, and included with the domain, workstation, and
username in the Type 3 message.  If the security context handle from the
Type 2 message <i>can</i> be validated, however, no responses are
 prepared whatsoever.  Instead, the default credentials are internally
 associated with the server context.  The resulting Type 3 message is
 completely empty, containing zero-length security buffers for the responses
as well as the username, domain, and workstation.
</li>
<li>
The server receives the Type 3 message and uses it as input to the
<tt>AcceptSecurityContext</tt> function.  The server verifies that the
security context has been associated with a user; if so, authentication
has successfully completed.  If the context has not been bound to a user,
authentication fails.
</li>
</ol>

<a name="datagramAuthentication">
<h3>Datagram Authentication</h3>
<p>
Datagram-style authentication is used to negotiate NTLM over a connectionless
transport.  While much of the semantics around the messages remain unchanged,
 there are a few significant differences:
<p>
<ul>
<li>
SSPI does not create a Type 1 message during the first call to
<tt>InitializeSecurityContext</tt>.
</li>
<li>
Authentication options are offered by the server, rather than requested by
the client.
</li>
<li>
Rather than being superfluous (as in connection-oriented authentication),
the flags in the Type 3 message carry their usual meanings.
</li>
</ul>
<p>
During "normal" (connection-oriented) authentication, all options are
 negotiated in the first transaction between the client and the server, during
 the exchange of the Type 1 and Type 2 messages.  The negotiated settings are
 "remembered" by the server and applied to the client's Type 3 message.
  Although most clients send the agreed-upon flags with the Type 3 message,
 they are not used in connection authentication.
<p>
In datagram authentication, however, the game changes a bit; to alleviate the
server's need to track the negotiated options (which becomes more difficult
without a persistent connection), the Type 1 message is removed completely.
  The server generates a Type 2 message containing all supported flags
 (as well as the challenge, of course).  The client then decides which options
 it will support, and replies with a Type 3 message containing the responses
 to the challenge and the set of selected flags.  The SSPI handshake sequence
 for datagram authentication is as follows:
<p>
<ol>
<li>
The client calls <tt>AcquireCredentialsHandle</tt> to obtain a representation
of the credential set for the user.
</li>
<li>
The client calls <tt>InitializeSecurityContext</tt>, passing the
<tt>ISC_REQ_DATAGRAM</tt> flag as a context requirement via the
fContextReq parameter.  This starts the construction of the client's security
context, but does <i>not</i> produce a request token (Type 1 message).
</li>
<li>
The server calls the <tt>AcceptSecurityContext</tt> function, specifying the
<tt>ASC_REQ_DATAGRAM</tt> context requirement flag and passing in a null
input token.  This creates the local security context and yields an
authentication response token (the Type 2 message).  This Type 2 message
will contain the "Negotiate Datagram Style" flag, as well as all flags
supported by the server.  This is sent to the client as usual.
</li>
<li>
The client receives the Type 2 message and passes it to
<tt>InitializeSecurityContext</tt>.  The client selects appropriate options
from those presented by the server (including "Negotiate Datagram Style",
which must be set), creates the responses to the challenge, and populates the
Type 3 message.  The message is then relayed to the server.
</li>
<li>
The server passes the Type 3 message into the <tt>AcceptSecurityContext</tt>
function.  The message is processed according to the flags selected by the
client, and the context is successfully accepted.
</li>
</ol>
<p>
When used with SSPI, there is apparently no means of producing a datagram-style
Type 1 message.  It is interesting to note, however, that we can "induce"
datagram semantics at a lower level by subtly manipulating the NTLMSSP tokens
to produce our own datagram Type 1 token.
<p>
This can be achieved by setting the "Negotiate Datagram Style" flag on the
Type 1 message produced by the first <tt>InitializeSecurityContext</tt> call
in a connection-oriented SSPI handshake before passing the token to the server.
When the modified Type 1 message is passed into the
 <tt>AcceptSecurityContext</tt> function, the server will adopt datagram
semantics (even though <tt>ASC_REQ_DATAGRAM</tt> was not specified).  This
will produce a Type 2 message with the "Negotiate Datagram Style" flag set,
but otherwise identical to the connection-oriented message that would normally
have been generated; that is, the Type 1 flags sent by the client are
considered during the construction of the Type 2 message, rather than simply
offering all supported options.
<p>
The client can then call <tt>InitializeSecurityContext</tt> with this Type 2
token.  Note that the client is still in connection-oriented mode; the Type 3
message produced will ignore the "Negotiate Datagram Style" flag applied to the
Type 2 message.  The server, however, is enforcing datagram semantics, and
will now require the Type 3 flags to be set appropriately.  Adding the
"Negotiate Datagram Style" flag to the Type 3 message manually before 
sending it to the server allows the server to successfully call
<tt>AcceptSecurityContext</tt> with the modified token.
<p>
This results in successful authentication; the "doctored" Type 1 message
effectively switches the server into datagram-style authentication, in
which the Type 3 flags are observed and enforced.  There is no known practical
use for this, but it does demonstrate some of the interesting and unexpected
behavior that can be observed by strategically manipulating the NTLM messages.
<p>
At this point, we have established a fairly decent fundamental understanding of
 NTLM.  We will now examine its use within some of Microsoft's network protocol
implementations.

<a name="ntlmHttpAuthentication">
<h2>NTLM HTTP Authentication</h2>
<p>
Microsoft has established the proprietary "NTLM" authentication scheme for HTTP
to provide integrated authentication to IIS web servers.  This authentication
mechanism allows clients to access resources using their Windows credentials,
and is typically used within corporate environments to provide single sign-on
functionality to intranet sites.  Historically, NTLM authentication was only
supported by Internet Explorer; recently, however, support has been added
to various other user agents.
<p>
The NTLM HTTP authentication mechanism works as follows:
<ol>
<li>
The client requests a protected resource from the server:
<pre>
    GET /index.html HTTP/1.1
</pre>
</li>
<li>
The server responds with a 401 status, indicating that the client must
authenticate.  "NTLM" is presented as a supported authentication mechanism
via the "<tt>WWW-Authenticate</tt>" header.  Typically, the server closes
the connection at this time:
<pre>
    HTTP/1.1 401 Unauthorized
    WWW-Authenticate: NTLM
    Connection: close
</pre>
<p>
Note that Internet Explorer will only select NTLM if it is the first
mechanism offered; this is at odds with RFC 2616, which states that the
client must select the strongest supported authentication scheme.
</li>
<li>
The client resubmits the request with an "<tt>Authorization</tt>" header
containing a Type 1 message parameter.  The Type 1 message is Base-64 encoded
for transmission.  From this point forward, the connection is kept open;
closing the connection requires reauthentication of subsequent requests.
This implies that the server and client must support persistent connections,
via either the HTTP 1.0-style "Keep-Alive" header or HTTP 1.1 (in which
persistent connections are employed by default).  The relevant request headers
appear as follows (the line break in the "<tt>Authorization</tt>" header below
is for display purposes only, and is not present in the actual message):
<pre>
    GET /index.html HTTP/1.1
    Authorization: NTLM TlRMTVNTUAABAAAABzIAAAYABgArAAAACwALACAAAABXT1
    JLU1RBVElPTkRPTUFJTg==
</pre>
</li>
<li>
The server replies with a 401 status containing a Type 2 message in the
"<tt>WWW-Authenticate</tt>" header (again, Base-64 encoded).  This is
shown below (the line breaks in the "<tt>WWW-Authenticate</tt>" header are
for editorial clarity only, and are not present in the actual header).
<pre>
    HTTP/1.1 401 Unauthorized
    WWW-Authenticate: NTLM TlRMTVNTUAACAAAADAAMADAAAAABAoEAASNFZ4mrze8
    AAAAAAAAAAGIAYgA8AAAARABPAE0AQQBJAE4AAgAMAEQATwBNAEEASQBOAAEADABTA
    EUAUgBWAEUAUgAEABQAZABvAG0AYQBpAG4ALgBjAG8AbQADACIAcwBlAHIAdgBlAHI
    ALgBkAG8AbQBhAGkAbgAuAGMAbwBtAAAAAAA=
</pre>
</li>
<li>
The client responds to the Type 2 message by resubmitting the request with
an "<tt>Authorization</tt>" header containing a Base-64 encoded Type 3 message
(again, the line breaks in the "<tt>Authorization</tt>" header below are for
display purposes only):
<pre>
    GET /index.html HTTP/1.1
    Authorization: NTLM TlRMTVNTUAADAAAAGAAYAGoAAAAYABgAggAAAAwADABAAA
    AACAAIAEwAAAAWABYAVAAAAAAAAACaAAAAAQIAAEQATwBNAEEASQBOAHUAcwBlAHIA
    VwBPAFIASwBTAFQAQQBUAEkATwBOAMM3zVy9RPyXgqZnr21CfG3mfCDC0+d8ViWpjB
    wx6BhHRmspst9GgPOZWPuMITqcxg==
</pre>
</li>
<li>
Finally, the server validates the responses in the client's Type 3 message and
allows access to the resource.
<pre>
    HTTP/1.1 200 OK
</pre>
</li>
</ol>
<p>
This scheme differs from most "normal" HTTP authentication mechanisms, in that
subsequent requests over the authenticated connection are not themselves
authenticated; NTLM is connection-oriented, rather than request-oriented.  So
a second request for "<tt>/index.html</tt>" would not carry any authentication
information, and the server would request none.  If the server detects that
the connection to the client has been dropped, a request for
"<tt>/index.html</tt>" would result in the server reinitiating the NTLM
handshake.
<p>
A notable exception to the above is the client's behavior when submitting
a POST request (typically employed when the client is sending form data to the
server).  If the client determines that the server is not the local host,
the <i>client</i> will initiate reauthentication for POST requests over the
active connection.  The client will first submit an empty POST request
with a Type 1 message in the "<tt>Authorization</tt>" header; the server
responds with the Type 2 message (in the "<tt>WWW-Authenticate</tt>" header
as shown above).  The client then resubmits the POST with the Type 3 message,
sending the form data with the request.
<p>
The NTLM HTTP mechanism can also be used for HTTP proxy authentication.  The
process is similar, except:
<ul>
<li>
The server uses the 407 response code (indicating proxy authentication
required) rather than 401.
</li>
<li>
The client's Type 1 and 3 messages are sent in the
"<tt>Proxy-Authorization</tt>" request header, rather than the
"<tt>Authorization</tt>" header.
</li>
<li>
The server's Type 2 challenge is sent in the "<tt>Proxy-Authenticate</tt>"
response header (instead of "<tt>WWW-Authenticate</tt>").
</li>
</ul>
<p>
With Windows 2000, Microsoft introduced the "Negotiate" HTTP authentication
mechanism.  While primarily aimed at providing a means of authenticating the
user against Active Directory via Kerberos, it is backward-compatible with
the NTLM scheme.  When the Negotiate mechanism is used in "legacy" mode,
the headers passed between the client and server are identical, except
"Negotiate" (rather than "NTLM") is indicated as the mechanism name.

<a name="ntlmPop3Authentication">
<h2>NTLM POP3 Authentication</h2>
<p>
Microsoft's Exchange server provides an NTLM authentication mechanism for the
POP3 protocol.  This is a proprietary extension used with the POP3
<tt>AUTH</tt> command as documented in
<a href="http://www.ietf.org/rfc/rfc1734.txt">RFC 1734</a>.  On the client
side, this mechanism is supported by Outlook and Outlook Express, and is called
"Secure Password Authentication".
<p>
The POP3 NTLM authentication handshake occurs during the POP3 "authorization"
state, and works as follows:
<ol>
<li>
The client may request a list of supported authentication mechanisms by
sending the <tt>AUTH</tt> command with no arguments:
<pre>
    AUTH
</pre>
</li>
<li>
The server responds with a success message, followed by the list of supported
mechanisms; this list should include "<tt>NTLM</tt>", and is terminated by a
line containing a single period ("<tt>.</tt>").
<pre>
    +OK The operation completed successfully.
    NTLM
    .
</pre>
<li>
The client initiates NTLM authentication by sending an <tt>AUTH</tt> command
specifying NTLM as the authentication mechanism:
<pre>
    AUTH NTLM
</pre>
</li>
<li>
The server responds with a success message as shown below.  Note that there
is a space between the "<tt>+</tt>" and the "<tt>OK</tt>"; RFC 1734 states
that the server should reply with a challenge, but NTLM requires the Type 1
message from the client.  So the server sends a "non-challenge", which is
basically the message "<tt>OK</tt>".
<pre>
    + OK
</pre>
</li>
<li>
The client then sends the Type 1 message, Base-64 encoded for transmission:
<pre>
    TlRMTVNTUAABAAAABzIAAAYABgArAAAACwALACAAAABXT1JLU1RBVElPTkRPTUFJTg==
</pre>
</li>
<li>
The server replies with the Type 2 challenge message (again, Base-64 encoded).
This is send in the challenge format specified by RFC 1734 ("<tt>+</tt>",
followed by a space, followed by the challenge message).  This is shown
below; the line breaks are for editorial clarity and are not present in the
server's reply:
<pre>
    + TlRMTVNTUAACAAAADAAMADAAAAABAoEAASNFZ4mrze8AAAAAAAAAAGIAYgA8AAAA
    RABPAE0AQQBJAE4AAgAMAEQATwBNAEEASQBOAAEADABTAEUAUgBWAEUAUgAEABQAZA
    BvAG0AYQBpAG4ALgBjAG8AbQADACIAcwBlAHIAdgBlAHIALgBkAG8AbQBhAGkAbgAu
    AGMAbwBtAAAAAAA=
</pre>
</li>
<li>
The client calculates and sends the Base-64 encoded Type 3 response (the
line breaks below are for display purposes only):
<pre>
    TlRMTVNTUAADAAAAGAAYAGoAAAAYABgAggAAAAwADABAAAAACAAIAEwAAAAWABYAVA
    AAAAAAAACaAAAAAQIAAEQATwBNAEEASQBOAHUAcwBlAHIAVwBPAFIASwBTAFQAQQBU
    AEkATwBOAMM3zVy9RPyXgqZnr21CfG3mfCDC0+d8ViWpjBwx6BhHRmspst9GgPOZWP
    uMITqcxg==
</pre>
</li>
<li>
The server validates the response and indicates the result of authentication:
<pre>
    +OK User successfully logged on
</pre>
</li>
</ol>
<p>
After successful authentication has occurred, the POP3 session enters the
"transaction" state, allowing messages to be retrieved by the client.

<a name="ntlmImapAuthentication">
<h2>NTLM IMAP Authentication</h2>
<p>
Exchange provides an IMAP authentication mechanism similar in form to the
POP3 mechanism previously discussed.  IMAP authentication is documented in
<a href="http://www.ietf.org/rfc/rfc1730.txt">RFC 1730</a>; the NTLM
mechanism is a proprietary extension provided by Exchange and supported
by the Outlook client family.
<p>
The handshake sequence is similar to the POP3 mechanism:
<ol>
<li>
The server may indicate support for the NTLM authentication mechanism in the
capability response.  Upon connecting to the IMAP server, the client would
request the list of server capabilities:
<pre>
    0000 CAPABILITY
</pre>
</li>
<li>
The server responds with the list of supported capabilities; the NTLM
authentication extension is indicated by the presence of the string
"<tt>AUTH=NTLM</tt>" in the server's reply:
<pre>
    * CAPABILITY IMAP4 IMAP4rev1 IDLE LITERAL+ AUTH=NTLM
    0000 OK CAPABILITY completed.
</pre>
<li>
The client initiates NTLM authentication by sending an <tt>AUTHENTICATE</tt>
command specifying NTLM as the authentication mechanism:
<pre>
    0001 AUTHENTICATE NTLM
</pre>
</li>
<li>
The server responds with an empty challenge, consisting simply of a
"<tt>+</tt>":
<pre>
    +
</pre>
</li>
<li>
The client then sends the Type 1 message, Base-64 encoded for transmission:
<pre>
    TlRMTVNTUAABAAAABzIAAAYABgArAAAACwALACAAAABXT1JLU1RBVElPTkRPTUFJTg==
</pre>
</li>
<li>
The server replies with the Type 2 challenge message (again, Base-64 encoded).
This is send in the challenge format specified by RFC 1730 ("<tt>+</tt>",
followed by a space, followed by the challenge message).  This is shown
below; the line breaks are for editorial clarity and are not present in the
server's reply:
<pre>
    + TlRMTVNTUAACAAAADAAMADAAAAABAoEAASNFZ4mrze8AAAAAAAAAAGIAYgA8AAAA
    RABPAE0AQQBJAE4AAgAMAEQATwBNAEEASQBOAAEADABTAEUAUgBWAEUAUgAEABQAZA
    BvAG0AYQBpAG4ALgBjAG8AbQADACIAcwBlAHIAdgBlAHIALgBkAG8AbQBhAGkAbgAu
    AGMAbwBtAAAAAAA=
</pre>
</li>
<li>
The client calculates and sends the Base-64 encoded Type 3 response (the
line breaks below are for display purposes only):
<pre>
    TlRMTVNTUAADAAAAGAAYAGoAAAAYABgAggAAAAwADABAAAAACAAIAEwAAAAWABYAVA
    AAAAAAAACaAAAAAQIAAEQATwBNAEEASQBOAHUAcwBlAHIAVwBPAFIASwBTAFQAQQBU
    AEkATwBOAMM3zVy9RPyXgqZnr21CfG3mfCDC0+d8ViWpjBwx6BhHRmspst9GgPOZWP
    uMITqcxg==
</pre>
</li>
<li>
The server validates the response and indicates the result of authentication:
<pre>
    0001 OK AUTHENTICATE NTLM completed.
</pre>
</li>
</ol>
After authentication has completed, the IMAP session enters the
authenticated state.

<a name="ntlmSmtpAuthentication">
<h2>NTLM SMTP Authentication</h2>
<p>
In addition to the NTLM authentication mechanisms provided for POP3 and IMAP,
Exchange provides similar functionality for the SMTP protocol.  This allows
NTLM authentication of users sending outgoing mail messages.  This is a
proprietary extension used with the SMTP <tt>AUTH</tt> command (documented in
<a href="http://www.ietf.org/rfc/rfc2554.txt">RFC 2554</a>).
<p>
The SMTP NTLM authentication handshake operates as follows:
<ol>
<li>
The server may indicate support for NTLM as an authentication mechanism
in the <tt>EHLO</tt> reply.  Upon connecting to the SMTP server, the client
would send the initial <tt>EHLO</tt> message:
<pre>
    EHLO client.example.com
</pre>
</li>
<li>
The server responds with the list of supported extensions; the NTLM
authentication extension is indicated by its presence in the list
of <tt>AUTH</tt> mechanisms as shown below.  Note that the <tt>AUTH</tt>
list is sent twice (once with an "<tt>=</tt>" and once without).  The
"<tt>AUTH=</tt>" form was apparently specified in a draft of the RFC;
sending both forms ensures that clients implemented against this draft are
supported.
<pre>
    250-server.example.com Hello [10.10.2.20]
    250-HELP
    250-AUTH LOGIN NTLM
    250-AUTH=LOGIN NTLM
    250 SIZE 10240000
</pre>
<li>
The client initiates NTLM authentication by sending an <tt>AUTH</tt>
command specifying NTLM as the authentication mechanism and providing the
Base-64 encoded Type 1 message as a parameter:
<pre>
    AUTH NTLM TlRMTVNTUAABAAAABzIAAAYABgArAAAACwALACAAAABXT1JLU1RBVElPTkRPTUFJTg==
</pre>
<p>
According to RFC 2554, the client may opt not to send the initial response
parameter (instead merely sending "<tt>AUTH NTLM</tt>" and waiting for an
empty server challenge before replying with the Type 1 message).  However,
this did not appear to work properly when tested against Exchange.
</li>
<li>
The server replies with a 334 response containing the Type 2 challenge
message (again, Base-64 encoded).  This is shown below; the line breaks are
for editorial clarity and are not present in the server's reply:
<pre>
    334 TlRMTVNTUAACAAAADAAMADAAAAABAoEAASNFZ4mrze8AAAAAAAAAAGIAYgA8AAAA
    RABPAE0AQQBJAE4AAgAMAEQATwBNAEEASQBOAAEADABTAEUAUgBWAEUAUgAEABQAZA
    BvAG0AYQBpAG4ALgBjAG8AbQADACIAcwBlAHIAdgBlAHIALgBkAG8AbQBhAGkAbgAu
    AGMAbwBtAAAAAAA=
</pre>
</li>
<li>
The client calculates and sends the Base-64 encoded Type 3 response (the
line breaks below are for display purposes only):
<pre>
    TlRMTVNTUAADAAAAGAAYAGoAAAAYABgAggAAAAwADABAAAAACAAIAEwAAAAWABYAVA
    AAAAAAAACaAAAAAQIAAEQATwBNAEEASQBOAHUAcwBlAHIAVwBPAFIASwBTAFQAQQBU
    AEkATwBOAMM3zVy9RPyXgqZnr21CfG3mfCDC0+d8ViWpjBwx6BhHRmspst9GgPOZWP
    uMITqcxg==
</pre>
</li>
<li>
The server validates the response and indicates the result of authentication:
<pre>
    235 NTLM authentication successful.
</pre>
</li>
</ol>
<p>
After authenticating, the client is able to send messages normally.

<a name="linksAndReferences">
<h2>Links and References</h2>
<p>
Note that due to the highly dynamic and transient nature of the Web,
these may or may not be available.
<p>
<dl>
    <dt><a href="http://jcifs.samba.org/">The jCIFS Project Home Page</a></dt>
    <dd>
    <i>http://jcifs.samba.org/</i>
    <br>
    jCIFS is an open-source Java implementation of CIFS/SMB.  The information
    presented in this article was used as the basis for the jCIFS
    NTLM implementation.  jCIFS provides support for both the
    client and server sides of the NTLM HTTP authentication scheme, as well
    as non-protocol-specific NTLM utility classes.
    </dd>
</dl>
<dl>
    <dt><a href="http://ubiqx.org/cifs/">Implementing CIFS: The Common Internet FileSystem</a></dt>
    <dd>
    <i>http://ubiqx.org/cifs/</i>
    <br>
    A highly informative online book by Christopher R. Hertel.  Especially
    relevant to this discussion is
    <a href="http://ubiqx.org/cifs/SMB.html#SMB.8">the section on authentication</a>.
    </dd>
</dl>
<dl>
    <dt><a href="http://www.opengroup.org/comsource/techref2/NCH1222X.HTM">The Open Group ActiveX Core Technology Reference (Chapter 11, "NTLM")</a></dt>
    <dd>
    <i>http://www.opengroup.org/comsource/techref2/NCH1222X.HTM</i>
    <br>
    Closest thing to an "official" reference on NTLM.  Unfortunately, also
    rather old and not terribly accurate.
    </dd>
</dl>
<dl>
    <dt><a href="http://www.microsoft.com/windows2000/techinfo/howitworks/security/sspi2000.asp">The Security Support Provider Interface</a></dt>
    <dd>
    <i>http://www.microsoft.com/windows2000/techinfo/howitworks/security/sspi2000.asp</i>
    <br>
    A whitepaper discussing application development using the SSPI.
    </dd>
</dl>
<dl>
    <dt><a href="http://www.innovation.ch/java/ntlm.html">NTLM Authentication Scheme for HTTP</a></dt>
    <dd>
    <i>http://www.innovation.ch/java/ntlm.html</i>
    <br>
    Informative discussion on the NTLM HTTP authentication mechanism.
    Inaccurate in some regards, but still quite useful.
    </dd>
</dl>
<dl>
    <dt><a href="http://squid.sourceforge.net/ntlm/">Squid NTLM Authentication Project</a></dt>
    <dd>
    <i>http://squid.sourceforge.net/ntlm/</i>
    <br>
    Project to provide NTLM HTTP authentication to the Squid proxy server.
    </dd>
</dl>
<dl>
    <dt><a href="http://jakarta.apache.org/commons/httpclient/">Jakarta Commons HttpClient</a></dt>
    <dd>
    <i>http://jakarta.apache.org/commons/httpclient/</i>
    <br>
    An open-source Java HTTP client which provides support for the NTLM
    HTTP authentication scheme.
    </dd>
</dl>
<dl>
    <dt><a href="http://www.gnu.org/software/gnu-crypto/">The GNU Crypto Project</a></dt>
    <dd>
    <i>http://www.gnu.org/software/gnu-crypto/</i>
    <br>
    An open-source Java Cryptography Extension provider supplying an
    implementation of the MD4 message-digest algorithm.
    </dd>
</dl>
<dl>
    <dt><a href="http://www.ietf.org/rfc/rfc1320.txt">RFC 1320 - The MD4 Message-Digest Algorithm</a></dt>
    <dd>
    <i>http://www.ietf.org/rfc/rfc1320.txt</i>
    <br>
    Specification and reference implementation for the MD4 digest (used to
    calculate the NTLM password hash).
    </dd>
</dl>
<dl>
    <dt><a href="http://www.ietf.org/rfc/rfc1321.txt">RFC 1321 - The MD5 Message-Digest Algorithm</a></dt>
    <dd>
    <i>http://www.ietf.org/rfc/rfc1321.txt</i>
    <br>
    Specification and reference implementation for the MD5 digest (used to
    calculate the NTLM2 session response).
    </dd>
</dl>
<dl>
    <dt><a href="http://www.ietf.org/rfc/rfc2104.txt">RFC 2104 - HMAC: Keyed-Hashing for Message Authentication</a></dt>
    <dd>
    <i>http://www.ietf.org/rfc/rfc2104.txt</i>
    <br>
    Specification and reference implementation for the HMAC-MD5 algorithm
    (used in the calculation of the NTLMv2/LMv2 responses).
    </dd>
</dl>
<dl>
    <dt><a href="http://support.microsoft.com/default.aspx?scid=KB;en-us;239869">How to Enable NTLM 2 Authentication</a></dt>
    <dd>
    <i>http://support.microsoft.com/default.aspx?scid=KB;en-us;239869</i>
    <br>
    Describes how to enable negotiation of NTLMv2 authentication and enforce
    NTLM security flags.
    </dd>
</dl>

<a name="appendixA">
<h2>Appendix A:  Java Implementation of the Type 3 Response Calculations</h2>
<p>
Listed below is an annotated sample implementation of the various Type 3
response calculations in Java.  This example requires a JCE provider
implementing the MD4 message-digest algorithm; the author recommends
GNU Crypto, available at
<a href="http://www.gnu.org/software/gnu-crypto/">http://www.gnu.org/software/gnu-crypto/</a>.
<p>
<div style="background: #fcfcfc; border: 1px lightgrey dotted; padding: 4px;">
<pre>
<font color="#a020f0">import</font> java.security.Key;
<font color="#a020f0">import</font> java.security.MessageDigest;

<font color="#a020f0">import</font> javax.crypto.Cipher;

<font color="#a020f0">import</font> javax.crypto.spec.SecretKeySpec;

<font color="#0000ff">/**</font>
<font color="#0000ff"> *</font><font color="#6a5acd"> Calculates the various Type 3 responses.</font>
<font color="#0000ff"> */</font>
<font color="#2e8b57"><b>public</b></font> <font color="#2e8b57"><b>class</b></font> Responses {
<a name="getLMResponse">
    <font color="#0000ff">/**</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> Calculates the LM Response for the given challenge, using the specified</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> password.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> password</font><font color="#0000ff"> The user's password.</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> challenge</font><font color="#0000ff"> The Type 2 challenge from the server.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@return</font><font color="#0000ff"> The LM Response.</font>
<font color="#0000ff">     */</font>
    <font color="#2e8b57"><b>public</b></font> <font color="#2e8b57"><b>static</b></font> <font color="#2e8b57"><b>byte</b></font>[] getLMResponse(String password, <font color="#2e8b57"><b>byte</b></font>[] challenge)
            <font color="#2e8b57"><b>throws</b></font> Exception {
        <font color="#2e8b57"><b>byte</b></font>[] lmHash = <a href="#lmHash">lmHash</a>(password);
        <font color="#804040"><b>return</b></font> <a href="#lmResponse">lmResponse</a>(lmHash, challenge);
    }
<a name="getNTLMResponse">
    <font color="#0000ff">/**</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> Calculates the NTLM Response for the given challenge, using the</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> specified password.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> password</font><font color="#0000ff"> The user's password.</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> challenge</font><font color="#0000ff"> The Type 2 challenge from the server.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@return</font><font color="#0000ff"> The NTLM Response.</font>
<font color="#0000ff">     */</font>
    <font color="#2e8b57"><b>public</b></font> <font color="#2e8b57"><b>static</b></font> <font color="#2e8b57"><b>byte</b></font>[] getNTLMResponse(String password, <font color="#2e8b57"><b>byte</b></font>[] challenge)
            <font color="#2e8b57"><b>throws</b></font> Exception {
        <font color="#2e8b57"><b>byte</b></font>[] ntlmHash = <a href="#ntlmHash">ntlmHash</a>(password);
        <font color="#804040"><b>return</b></font> <a href="#lmResponse">lmResponse</a>(ntlmHash, challenge);
    }
<a name="getNTLMv2Response">
    <font color="#0000ff">/**</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> Calculates the NTLMv2 Response for the given challenge, using the</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> specified authentication target, username, password, target information</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> block, and client challenge.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> target</font><font color="#0000ff"> The authentication target (i.e., domain).</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> user</font><font color="#0000ff"> The username. </font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> password</font><font color="#0000ff"> The user's password.</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> targetInformation</font><font color="#0000ff"> The target information block from the Type 2</font>
<font color="#0000ff">     * message.</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> challenge</font><font color="#0000ff"> The Type 2 challenge from the server.</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> clientChallenge</font><font color="#0000ff"> The random 8-byte client challenge. </font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@return</font><font color="#0000ff"> The NTLMv2 Response.</font>
<font color="#0000ff">     */</font>
    <font color="#2e8b57"><b>public</b></font> <font color="#2e8b57"><b>static</b></font> <font color="#2e8b57"><b>byte</b></font>[] getNTLMv2Response(String target, String user,
            String password, <font color="#2e8b57"><b>byte</b></font>[] targetInformation, <font color="#2e8b57"><b>byte</b></font>[] challenge,
                    <font color="#2e8b57"><b>byte</b></font>[] clientChallenge) <font color="#2e8b57"><b>throws</b></font> Exception {
        <font color="#2e8b57"><b>byte</b></font>[] ntlmv2Hash = <a href="#ntlmv2Hash">ntlmv2Hash</a>(target, user, password);
        <font color="#2e8b57"><b>byte</b></font>[] blob = <a href="#createBlob">createBlob</a>(targetInformation, clientChallenge);
        <font color="#804040"><b>return</b></font> <a href="#lmv2Response">lmv2Response</a>(ntlmv2Hash, blob, challenge);
    }
<a name="getLMv2Response">
    <font color="#0000ff">/**</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> Calculates the LMv2 Response for the given challenge, using the</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> specified authentication target, username, password, and client</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> challenge.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> target</font><font color="#0000ff"> The authentication target (i.e., domain).</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> user</font><font color="#0000ff"> The username.</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> password</font><font color="#0000ff"> The user's password.</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> challenge</font><font color="#0000ff"> The Type 2 challenge from the server.</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> clientChallenge</font><font color="#0000ff"> The random 8-byte client challenge.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@return</font><font color="#0000ff"> The LMv2 Response. </font>
<font color="#0000ff">     */</font>
    <font color="#2e8b57"><b>public</b></font> <font color="#2e8b57"><b>static</b></font> <font color="#2e8b57"><b>byte</b></font>[] getLMv2Response(String target, String user,
            String password, <font color="#2e8b57"><b>byte</b></font>[] challenge, <font color="#2e8b57"><b>byte</b></font>[] clientChallenge)
                    <font color="#2e8b57"><b>throws</b></font> Exception {
        <font color="#2e8b57"><b>byte</b></font>[] ntlmv2Hash = <a href="#ntlmv2Hash">ntlmv2Hash</a>(target, user, password);
        <font color="#804040"><b>return</b></font> <a href="#lmv2Response">lmv2Response</a>(ntlmv2Hash, clientChallenge, challenge);
    }
<a name="getNTLM2SessionResponse">
    <font color="#0000ff">/**</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> Calculates the NTLM2 Session Response for the given challenge, using the</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> specified password and client challenge.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> password</font><font color="#0000ff"> The user's password.</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> challenge</font><font color="#0000ff"> The Type 2 challenge from the server.</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> clientChallenge</font><font color="#0000ff"> The random 8-byte client challenge.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@return</font><font color="#0000ff"> The NTLM2 Session Response.  This is placed in the NTLM</font>
<font color="#0000ff">     * response field of the Type 3 message; the LM response field contains</font>
<font color="#0000ff">     * the client challenge, null-padded to 24 bytes.</font>
<font color="#0000ff">     */</font>
    <font color="#2e8b57"><b>public</b></font> <font color="#2e8b57"><b>static</b></font> <font color="#2e8b57"><b>byte</b></font>[] getNTLM2SessionResponse(String password,
            <font color="#2e8b57"><b>byte</b></font>[] challenge, <font color="#2e8b57"><b>byte</b></font>[] clientChallenge) <font color="#2e8b57"><b>throws</b></font> Exception {
        <font color="#2e8b57"><b>byte</b></font>[] ntlmHash = ntlmHash(password);
        MessageDigest md5 = MessageDigest.getInstance(<font color="#ff00ff">&quot;MD5&quot;</font>);
        md5.update(challenge);
        md5.update(clientChallenge);
        <font color="#2e8b57"><b>byte</b></font>[] sessionHash = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[<font color="#ff00ff">8</font>];
        System.arraycopy(md5.digest(), <font color="#ff00ff">0</font>, sessionHash, <font color="#ff00ff">0</font>, <font color="#ff00ff">8</font>);
        <font color="#804040"><b>return</b></font> lmResponse(ntlmHash, sessionHash);
    }
<a name="lmHash">
    <font color="#0000ff">/**</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> Creates the LM Hash of the user's password.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> password</font><font color="#0000ff"> The password.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@return</font><font color="#0000ff"> The LM Hash of the given password, used in the calculation</font>
<font color="#0000ff">     * of the LM Response.</font>
<font color="#0000ff">     */</font>
    <font color="#2e8b57"><b>private</b></font> <font color="#2e8b57"><b>static</b></font> <font color="#2e8b57"><b>byte</b></font>[] lmHash(String password) <font color="#2e8b57"><b>throws</b></font> Exception {
        <font color="#2e8b57"><b>byte</b></font>[] oemPassword = password.toUpperCase().getBytes(<font color="#ff00ff">&quot;US-ASCII&quot;</font>);
        <font color="#2e8b57"><b>int</b></font> length = Math.min(oemPassword.length, <font color="#ff00ff">14</font>);
        <font color="#2e8b57"><b>byte</b></font>[] keyBytes = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[<font color="#ff00ff">14</font>];
        System.arraycopy(oemPassword, <font color="#ff00ff">0</font>, keyBytes, <font color="#ff00ff">0</font>, length);
        Key lowKey = <a href="#createDESKey">createDESKey</a>(keyBytes, <font color="#ff00ff">0</font>);
        Key highKey = <a href="#createDESKey">createDESKey</a>(keyBytes, <font color="#ff00ff">7</font>);
        <font color="#2e8b57"><b>byte</b></font>[] magicConstant = <font color="#ff00ff">&quot;KGS!@#$%&quot;</font>.getBytes(<font color="#ff00ff">&quot;US-ASCII&quot;</font>);
        Cipher des = Cipher.getInstance(<font color="#ff00ff">&quot;DES/ECB/NoPadding&quot;</font>);
        des.init(Cipher.ENCRYPT_MODE, lowKey);
        <font color="#2e8b57"><b>byte</b></font>[] lowHash = des.doFinal(magicConstant);
        des.init(Cipher.ENCRYPT_MODE, highKey);
        <font color="#2e8b57"><b>byte</b></font>[] highHash = des.doFinal(magicConstant);
        <font color="#2e8b57"><b>byte</b></font>[] lmHash = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[<font color="#ff00ff">16</font>];
        System.arraycopy(lowHash, <font color="#ff00ff">0</font>, lmHash, <font color="#ff00ff">0</font>, <font color="#ff00ff">8</font>);
        System.arraycopy(highHash, <font color="#ff00ff">0</font>, lmHash, <font color="#ff00ff">8</font>, <font color="#ff00ff">8</font>);
        <font color="#804040"><b>return</b></font> lmHash;
    }
<a name="ntlmHash">
    <font color="#0000ff">/**</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> Creates the NTLM Hash of the user's password.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> password</font><font color="#0000ff"> The password.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@return</font><font color="#0000ff"> The NTLM Hash of the given password, used in the calculation</font>
<font color="#0000ff">     * of the NTLM Response and the NTLMv2 and LMv2 Hashes.</font>
<font color="#0000ff">     */</font>
    <font color="#2e8b57"><b>private</b></font> <font color="#2e8b57"><b>static</b></font> <font color="#2e8b57"><b>byte</b></font>[] ntlmHash(String password) <font color="#2e8b57"><b>throws</b></font> Exception {
        <font color="#2e8b57"><b>byte</b></font>[] unicodePassword = password.getBytes(<font color="#ff00ff">&quot;UnicodeLittleUnmarked&quot;</font>);
        MessageDigest md4 = MessageDigest.getInstance(<font color="#ff00ff">&quot;MD4&quot;</font>);
        <font color="#804040"><b>return</b></font> md4.digest(unicodePassword);
    }
<a name="ntlmv2Hash">
    <font color="#0000ff">/**</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> Creates the NTLMv2 Hash of the user's password.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> target</font><font color="#0000ff"> The authentication target (i.e., domain).</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> user</font><font color="#0000ff"> The username.</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> password</font><font color="#0000ff"> The password.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@return</font><font color="#0000ff"> The NTLMv2 Hash, used in the calculation of the NTLMv2</font>
<font color="#0000ff">     * and LMv2 Responses. </font>
<font color="#0000ff">     */</font>
    <font color="#2e8b57"><b>private</b></font> <font color="#2e8b57"><b>static</b></font> <font color="#2e8b57"><b>byte</b></font>[] ntlmv2Hash(String target, String user,
            String password) <font color="#2e8b57"><b>throws</b></font> Exception {
        <font color="#2e8b57"><b>byte</b></font>[] ntlmHash = <a href="#ntlmHash">ntlmHash</a>(password);
        String identity = user.toUpperCase() + target.toUpperCase();
        <font color="#804040"><b>return</b></font> <a href="#hmacMD5">hmacMD5</a>(identity.getBytes(<font color="#ff00ff">&quot;UnicodeLittleUnmarked&quot;</font>), ntlmHash);
    }
<a name="lmResponse">
    <font color="#0000ff">/**</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> Creates the LM Response from the given hash and Type 2 challenge.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> hash</font><font color="#0000ff"> The LM or NTLM Hash.</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> challenge</font><font color="#0000ff"> The server challenge from the Type 2 message.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@return</font><font color="#0000ff"> The response (either LM or NTLM, depending on the provided</font>
<font color="#0000ff">     * hash).</font>
<font color="#0000ff">     */</font>
    <font color="#2e8b57"><b>private</b></font> <font color="#2e8b57"><b>static</b></font> <font color="#2e8b57"><b>byte</b></font>[] lmResponse(<font color="#2e8b57"><b>byte</b></font>[] hash, <font color="#2e8b57"><b>byte</b></font>[] challenge)
            <font color="#2e8b57"><b>throws</b></font> Exception {
        <font color="#2e8b57"><b>byte</b></font>[] keyBytes = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[<font color="#ff00ff">21</font>];
        System.arraycopy(hash, <font color="#ff00ff">0</font>, keyBytes, <font color="#ff00ff">0</font>, <font color="#ff00ff">16</font>);
        Key lowKey = <a href="#createDESKey">createDESKey</a>(keyBytes, <font color="#ff00ff">0</font>);
        Key middleKey = <a href="#createDESKey">createDESKey</a>(keyBytes, <font color="#ff00ff">7</font>);
        Key highKey = <a href="#createDESKey">createDESKey</a>(keyBytes, <font color="#ff00ff">14</font>);
        Cipher des = Cipher.getInstance(<font color="#ff00ff">&quot;DES/ECB/NoPadding&quot;</font>);
        des.init(Cipher.ENCRYPT_MODE, lowKey);
        <font color="#2e8b57"><b>byte</b></font>[] lowResponse = des.doFinal(challenge);
        des.init(Cipher.ENCRYPT_MODE, middleKey);
        <font color="#2e8b57"><b>byte</b></font>[] middleResponse = des.doFinal(challenge);
        des.init(Cipher.ENCRYPT_MODE, highKey);
        <font color="#2e8b57"><b>byte</b></font>[] highResponse = des.doFinal(challenge);
        <font color="#2e8b57"><b>byte</b></font>[] lmResponse = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[<font color="#ff00ff">24</font>];
        System.arraycopy(lowResponse, <font color="#ff00ff">0</font>, lmResponse, <font color="#ff00ff">0</font>, <font color="#ff00ff">8</font>);
        System.arraycopy(middleResponse, <font color="#ff00ff">0</font>, lmResponse, <font color="#ff00ff">8</font>, <font color="#ff00ff">8</font>);
        System.arraycopy(highResponse, <font color="#ff00ff">0</font>, lmResponse, <font color="#ff00ff">16</font>, <font color="#ff00ff">8</font>);
        <font color="#804040"><b>return</b></font> lmResponse;
    }
<a name="lmv2Response">
    <font color="#0000ff">/**</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> Creates the LMv2 Response from the given hash, client data, and</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> Type 2 challenge.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> hash</font><font color="#0000ff"> The NTLMv2 Hash.</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> clientData</font><font color="#0000ff"> The client data (blob or client challenge).</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> challenge</font><font color="#0000ff"> The server challenge from the Type 2 message.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@return</font><font color="#0000ff"> The response (either NTLMv2 or LMv2, depending on the</font>
<font color="#0000ff">     * client data).</font>
<font color="#0000ff">     */</font>
    <font color="#2e8b57"><b>private</b></font> <font color="#2e8b57"><b>static</b></font> <font color="#2e8b57"><b>byte</b></font>[] lmv2Response(<font color="#2e8b57"><b>byte</b></font>[] hash, <font color="#2e8b57"><b>byte</b></font>[] clientData,
            <font color="#2e8b57"><b>byte</b></font>[] challenge) <font color="#2e8b57"><b>throws</b></font> Exception {
        <font color="#2e8b57"><b>byte</b></font>[] data = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[challenge.length + clientData.length];
        System.arraycopy(challenge, <font color="#ff00ff">0</font>, data, <font color="#ff00ff">0</font>, challenge.length);
        System.arraycopy(clientData, <font color="#ff00ff">0</font>, data, challenge.length,
                         clientData.length);
        <font color="#2e8b57"><b>byte</b></font>[] mac = <a href="#hmacMD5">hmacMD5</a>(data, hash);
        <font color="#2e8b57"><b>byte</b></font>[] lmv2Response = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[mac.length + clientData.length];
        System.arraycopy(mac, <font color="#ff00ff">0</font>, lmv2Response, <font color="#ff00ff">0</font>, mac.length);
        System.arraycopy(clientData, <font color="#ff00ff">0</font>, lmv2Response, mac.length,
                         clientData.length);
        <font color="#804040"><b>return</b></font> lmv2Response;
    }
<a name="createBlob">
    <font color="#0000ff">/**</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> Creates the NTLMv2 blob from the given target information block and</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> client challenge.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> targetInformation</font><font color="#0000ff"> The target information block from the Type 2</font>
<font color="#0000ff">     * message.</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> clientChallenge</font><font color="#0000ff"> The random 8-byte client challenge.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@return</font><font color="#0000ff"> The blob, used in the calculation of the NTLMv2 Response.</font>
<font color="#0000ff">     */</font>
    <font color="#2e8b57"><b>private</b></font> <font color="#2e8b57"><b>static</b></font> <font color="#2e8b57"><b>byte</b></font>[] createBlob(<font color="#2e8b57"><b>byte</b></font>[] targetInformation,
            <font color="#2e8b57"><b>byte</b></font>[] clientChallenge) {
        <font color="#2e8b57"><b>byte</b></font>[] blobSignature = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[] {
            (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x01</font>, (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x01</font>, (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x00</font>, (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x00</font>
        };
        <font color="#2e8b57"><b>byte</b></font>[] reserved = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[] {
            (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x00</font>, (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x00</font>, (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x00</font>, (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x00</font>
        };
        <font color="#2e8b57"><b>byte</b></font>[] unknown1 = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[] {
            (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x00</font>, (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x00</font>, (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x00</font>, (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x00</font>
        };
        <font color="#2e8b57"><b>byte</b></font>[] unknown2 = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[] {
            (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x00</font>, (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x00</font>, (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x00</font>, (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x00</font>
        };
        <font color="#2e8b57"><b>long</b></font> time = System.currentTimeMillis();
        time += <font color="#ff00ff">11644473600000l</font>; <font color="#0000ff">// milliseconds from January 1, 1601 -&gt; epoch.</font>
        time *= <font color="#ff00ff">10000</font>; <font color="#0000ff">// tenths of a microsecond.</font>
        <font color="#0000ff">// convert to little-endian byte array.</font>
        <font color="#2e8b57"><b>byte</b></font>[] timestamp = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[<font color="#ff00ff">8</font>];
        <font color="#804040"><b>for</b></font> (<font color="#2e8b57"><b>int</b></font> i = <font color="#ff00ff">0</font>; i &lt; <font color="#ff00ff">8</font>; i++) {
            timestamp[i] = (<font color="#2e8b57"><b>byte</b></font>) time;
            time &gt;&gt;&gt;= <font color="#ff00ff">8</font>;
        }
        <font color="#2e8b57"><b>byte</b></font>[] blob = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[blobSignature.length + reserved.length +
                               timestamp.length + clientChallenge.length +
                               unknown1.length + targetInformation.length +
                               unknown2.length];
        <font color="#2e8b57"><b>int</b></font> offset = <font color="#ff00ff">0</font>;
        System.arraycopy(blobSignature, <font color="#ff00ff">0</font>, blob, offset, blobSignature.length);
        offset += blobSignature.length;
        System.arraycopy(reserved, <font color="#ff00ff">0</font>, blob, offset, reserved.length);
        offset += reserved.length;
        System.arraycopy(timestamp, <font color="#ff00ff">0</font>, blob, offset, timestamp.length);
        offset += timestamp.length;
        System.arraycopy(clientChallenge, <font color="#ff00ff">0</font>, blob, offset,
                         clientChallenge.length);
        offset += clientChallenge.length;
        System.arraycopy(unknown1, <font color="#ff00ff">0</font>, blob, offset, unknown1.length);
        offset += unknown1.length;
        System.arraycopy(targetInformation, <font color="#ff00ff">0</font>, blob, offset,
                         targetInformation.length);
        offset += targetInformation.length;
        System.arraycopy(unknown2, <font color="#ff00ff">0</font>, blob, offset, unknown2.length);
        <font color="#804040"><b>return</b></font> blob;
    }
<a name="hmacMD5">
    <font color="#0000ff">/**</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> Calculates the HMAC-MD5 hash of the given data using the specified</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> hashing key.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> data</font><font color="#0000ff"> The data for which the hash will be calculated. </font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> key</font><font color="#0000ff"> The hashing key.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@return</font><font color="#0000ff"> The HMAC-MD5 hash of the given data.</font>
<font color="#0000ff">     */</font>
    <font color="#2e8b57"><b>private</b></font> <font color="#2e8b57"><b>static</b></font> <font color="#2e8b57"><b>byte</b></font>[] hmacMD5(<font color="#2e8b57"><b>byte</b></font>[] data, <font color="#2e8b57"><b>byte</b></font>[] key) <font color="#2e8b57"><b>throws</b></font> Exception {
        <font color="#2e8b57"><b>byte</b></font>[] ipad = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[<font color="#ff00ff">64</font>];
        <font color="#2e8b57"><b>byte</b></font>[] opad = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[<font color="#ff00ff">64</font>];
        <font color="#804040"><b>for</b></font> (<font color="#2e8b57"><b>int</b></font> i = <font color="#ff00ff">0</font>; i &lt; <font color="#ff00ff">64</font>; i++) {
            ipad[i] = (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x36</font>;
            opad[i] = (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x5c</font>;
        }
        <font color="#804040"><b>for</b></font> (<font color="#2e8b57"><b>int</b></font> i = key.length - <font color="#ff00ff">1</font>; i &gt;= <font color="#ff00ff">0</font>; i--) {
            ipad[i] ^= key[i];
            opad[i] ^= key[i];
        }
        <font color="#2e8b57"><b>byte</b></font>[] content = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[data.length + <font color="#ff00ff">64</font>];
        System.arraycopy(ipad, <font color="#ff00ff">0</font>, content, <font color="#ff00ff">0</font>, <font color="#ff00ff">64</font>);
        System.arraycopy(data, <font color="#ff00ff">0</font>, content, <font color="#ff00ff">64</font>, data.length);
        MessageDigest md5 = MessageDigest.getInstance(<font color="#ff00ff">&quot;MD5&quot;</font>);
        data = md5.digest(content);
        content = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[data.length + <font color="#ff00ff">64</font>];
        System.arraycopy(opad, <font color="#ff00ff">0</font>, content, <font color="#ff00ff">0</font>, <font color="#ff00ff">64</font>);
        System.arraycopy(data, <font color="#ff00ff">0</font>, content, <font color="#ff00ff">64</font>, data.length);
        <font color="#804040"><b>return</b></font> md5.digest(content);
    }
<a name="createDESKey">
    <font color="#0000ff">/**</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> Creates a DES encryption key from the given key material.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> bytes</font><font color="#0000ff"> A byte array containing the DES key material.</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> offset</font><font color="#0000ff"> The offset in the given byte array at which</font>
<font color="#0000ff">     * the 7-byte key material starts.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@return</font><font color="#0000ff"> A DES encryption key created from the key material</font>
<font color="#0000ff">     * starting at the specified offset in the given byte array.</font>
<font color="#0000ff">     */</font>
    <font color="#2e8b57"><b>private</b></font> <font color="#2e8b57"><b>static</b></font> Key createDESKey(<font color="#2e8b57"><b>byte</b></font>[] bytes, <font color="#2e8b57"><b>int</b></font> offset) {
        <font color="#2e8b57"><b>byte</b></font>[] keyBytes = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[<font color="#ff00ff">7</font>];
        System.arraycopy(bytes, offset, keyBytes, <font color="#ff00ff">0</font>, <font color="#ff00ff">7</font>);
        <font color="#2e8b57"><b>byte</b></font>[] material = <font color="#804040"><b>new</b></font> <font color="#2e8b57"><b>byte</b></font>[<font color="#ff00ff">8</font>];
        material[<font color="#ff00ff">0</font>] = keyBytes[<font color="#ff00ff">0</font>];
        material[<font color="#ff00ff">1</font>] = (<font color="#2e8b57"><b>byte</b></font>) (keyBytes[<font color="#ff00ff">0</font>] &lt;&lt; <font color="#ff00ff">7</font> | (keyBytes[<font color="#ff00ff">1</font>] &amp; <font color="#ff00ff">0xff</font>) &gt;&gt;&gt; <font color="#ff00ff">1</font>);
        material[<font color="#ff00ff">2</font>] = (<font color="#2e8b57"><b>byte</b></font>) (keyBytes[<font color="#ff00ff">1</font>] &lt;&lt; <font color="#ff00ff">6</font> | (keyBytes[<font color="#ff00ff">2</font>] &amp; <font color="#ff00ff">0xff</font>) &gt;&gt;&gt; <font color="#ff00ff">2</font>);
        material[<font color="#ff00ff">3</font>] = (<font color="#2e8b57"><b>byte</b></font>) (keyBytes[<font color="#ff00ff">2</font>] &lt;&lt; <font color="#ff00ff">5</font> | (keyBytes[<font color="#ff00ff">3</font>] &amp; <font color="#ff00ff">0xff</font>) &gt;&gt;&gt; <font color="#ff00ff">3</font>);
        material[<font color="#ff00ff">4</font>] = (<font color="#2e8b57"><b>byte</b></font>) (keyBytes[<font color="#ff00ff">3</font>] &lt;&lt; <font color="#ff00ff">4</font> | (keyBytes[<font color="#ff00ff">4</font>] &amp; <font color="#ff00ff">0xff</font>) &gt;&gt;&gt; <font color="#ff00ff">4</font>);
        material[<font color="#ff00ff">5</font>] = (<font color="#2e8b57"><b>byte</b></font>) (keyBytes[<font color="#ff00ff">4</font>] &lt;&lt; <font color="#ff00ff">3</font> | (keyBytes[<font color="#ff00ff">5</font>] &amp; <font color="#ff00ff">0xff</font>) &gt;&gt;&gt; <font color="#ff00ff">5</font>);
        material[<font color="#ff00ff">6</font>] = (<font color="#2e8b57"><b>byte</b></font>) (keyBytes[<font color="#ff00ff">5</font>] &lt;&lt; <font color="#ff00ff">2</font> | (keyBytes[<font color="#ff00ff">6</font>] &amp; <font color="#ff00ff">0xff</font>) &gt;&gt;&gt; <font color="#ff00ff">6</font>);
        material[<font color="#ff00ff">7</font>] = (<font color="#2e8b57"><b>byte</b></font>) (keyBytes[<font color="#ff00ff">6</font>] &lt;&lt; <font color="#ff00ff">1</font>);
        <a href="#oddParity">oddParity</a>(material);
        <font color="#804040"><b>return</b></font> <font color="#804040"><b>new</b></font> SecretKeySpec(material, <font color="#ff00ff">&quot;DES&quot;</font>);
    }
<a name="oddParity">
    <font color="#0000ff">/**</font>
<font color="#0000ff">     *</font><font color="#6a5acd"> Applies odd parity to the given byte array.</font>
<font color="#0000ff">     *</font>
<font color="#0000ff">     * </font><font color="#6a5acd">@param</font><font color="#008080"> bytes</font><font color="#0000ff"> The data whose parity bits are to be adjusted for</font>
<font color="#0000ff">     * odd parity.</font>
<font color="#0000ff">     */</font>
    <font color="#2e8b57"><b>private</b></font> <font color="#2e8b57"><b>static</b></font> <font color="#2e8b57"><b>void</b></font> oddParity(<font color="#2e8b57"><b>byte</b></font>[] bytes) {
        <font color="#804040"><b>for</b></font> (<font color="#2e8b57"><b>int</b></font> i = <font color="#ff00ff">0</font>; i &lt; bytes.length; i++) {
            <font color="#2e8b57"><b>byte</b></font> b = bytes[i];
            <font color="#2e8b57"><b>boolean</b></font> needsParity = (((b &gt;&gt;&gt; <font color="#ff00ff">7</font>) ^ (b &gt;&gt;&gt; <font color="#ff00ff">6</font>) ^ (b &gt;&gt;&gt; <font color="#ff00ff">5</font>) ^
                                    (b &gt;&gt;&gt; <font color="#ff00ff">4</font>) ^ (b &gt;&gt;&gt; <font color="#ff00ff">3</font>) ^ (b &gt;&gt;&gt; <font color="#ff00ff">2</font>) ^
                                    (b &gt;&gt;&gt; <font color="#ff00ff">1</font>)) &amp; <font color="#ff00ff">0x01</font>) == <font color="#ff00ff">0</font>;
            <font color="#804040"><b>if</b></font> (needsParity) {
                bytes[i] |= (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0x01</font>;
            } <font color="#804040"><b>else</b></font> {
                bytes[i] &amp;= (<font color="#2e8b57"><b>byte</b></font>) <font color="#ff00ff">0xfe</font>;
            }
        }
    }

}
</pre>
</div>

<p>
<hr>
<small>
    <p>
    <a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=78146&amp;type=5" width="210" height="62" border="0" alt="SourceForge.net Logo"></a>
    </p>
    <p>
    All trademarks mentioned in this document are the property of their
    respective owners.
</small>
</body>
</html>
